globals
	constant real a = 3.14159
	constant real b = 2.71828
	constant real c = 128.0
	constant real d = 128.0
	constant real e = 270.0
	constant real f = 180.0 / a
	constant real g = a / 180.0
	constant real h = 20.00
	constant real i = 20.00
	constant real j = 20.00
	constant real k = 20.00
	constant real l = 20.00
	constant real m = 20.00
	constant real n = 12.00
	constant real o = 12.00
	constant real p = 10.00
	constant real q = 15.00
	constant real r = 10.00
	constant real s = 10.00
	constant real t = 12.00
	constant real u = 5.00
	constant real v = 5.00
	constant real w = 3.00
	constant real x = 60.00
	constant real y = 0.01
	constant real z = 0.10
	constant real A = 0.10
	constant real B = 2.00
	constant integer C = 6
	constant integer D = 12
	constant integer E = 13
	constant integer F = 14
	constant integer G = 16
	constant integer H = 25
	constant integer I = 11
	constant integer J = 11
	constant integer K = 10
	constant real L = 6.00
	constant real M = 18.00
	constant real N = 8.00
	constant integer O = 750
	constant integer P = 500
	constant integer Q = 200
	constant integer R = 150
	constant integer S = 1
	constant integer T = 3
	constant integer U = 1
	constant real V = 2000
	constant real W = 1500
	constant real X = 120.00
	constant real Y = 20.00
	constant integer Z = 3
	constant integer ab = 1
	constant real bb = 0.50
	constant real cb = 120
	constant real db = 30
	constant integer eb = 20
	constant integer fb = 64
	constant integer gb = 100
	constant integer hb = 1650
	constant integer ib = 5000
	constant integer jb = 304
	constant integer kb = 70
	constant integer lb = 0
	constant integer mb = 90
	constant real nb = 2.00
	constant real ob = 5.00
	constant real pb = 1.00
	constant integer qb = 255
	constant integer rb = 255
	constant integer sb = 255
	constant integer tb = 255
	constant real ub = 1.50
	constant real vb = 0.50
	constant gamespeed wb = 
	constant real xb = 0.40
	constant real yb = 0.00
	constant real zb = 0.40
	constant real Ab = 0.40
	constant real Bb = 0.00
	constant real Cb = 0.55
	constant real Db = 1.00
	constant real Eb = 0.60
	constant real Fb = 0.25
	constant real Gb = 0.00
	constant real Hb = 0.25
	constant real Ib = 0.25
	constant real Jb = 0.00
	constant real Kb = 0.55
	constant real Lb = 1.00
	constant real Mb = 0.60
	constant real Nb = 500
	constant real Ob = 3500
	constant integer Pb = 100
	constant real Qb = 180.00
	constant integer Rb = 0
	constant integer Sb = 1
	constant integer Tb = 2
	constant integer Ub = 3
	constant integer Vb = 4
	constant integer Wb = 5
	constant integer Xb = 6
	constant integer Yb = 7
	constant integer Zb = 8
	constant integer ac = 0
	constant integer bc = 1
	constant integer cc = 2
	constant integer dc = 3
	constant integer ec = 4
	constant integer fc = 0
	constant integer gc = 1
	constant integer hc = 2
	constant integer ic = 3
	constant integer jc = ac * 1000 + 0
	constant integer kc = ac * 1000 + 1
	constant integer lc = bc * 1000 + 0
	constant integer mc = bc * 1000 + 1
	constant integer nc = bc * 1000 + 2
	constant integer oc = bc * 1000 + 3
	constant integer pc = bc * 1000 + 4
	constant integer qc = bc * 1000 + 5
	constant integer rc = bc * 1000 + 6
	constant integer sc = bc * 1000 + 7
	constant integer tc = bc * 1000 + 8
	constant integer uc = bc * 1000 + 9
	constant integer vc = bc * 1000 + 10
	constant integer wc = bc * 1000 + 11
	constant integer xc = cc * 1000 + 0
	constant integer yc = cc * 1000 + 1
	constant integer zc = cc * 1000 + 2
	constant integer Ac = cc * 1000 + 3
	constant integer Bc = cc * 1000 + 4
	constant integer Cc = cc * 1000 + 5
	constant integer Dc = cc * 1000 + 6
	constant integer Ec = cc * 1000 + 7
	constant integer Fc = cc * 1000 + 8
	constant integer Gc = cc * 1000 + 9
	constant integer Hc = dc * 1000 + 0
	constant integer Ic = dc * 1000 + 1
	constant integer Jc = dc * 1000 + 2
	constant integer Kc = dc * 1000 + 3
	constant integer Lc = dc * 1000 + 4
	constant integer Mc = dc * 1000 + 5
	constant integer Nc = dc * 1000 + 6
	constant integer Oc = dc * 1000 + 7
	constant integer Pc = dc * 1000 + 8
	constant integer Qc = dc * 1000 + 9
	constant integer Rc = dc * 1000 + 10
	constant integer Sc = ec * 1000 + 0
	constant integer Tc = ec * 1000 + 1
	constant integer Uc = ec * 1000 + 2
	constant integer Vc = ec * 1000 + 3
	constant integer Wc = ec * 1000 + 4
	constant integer Xc = ec * 1000 + 5
	constant integer Yc = ec * 1000 + 6
	constant integer Zc = ec * 1000 + 7
	constant integer ad = ec * 1000 + 8
	constant integer bd = ec * 1000 + 9
	constant integer cd = fc * 1000 + 0
	constant integer dd = fc * 1000 + 1
	constant integer ed = fc * 1000 + 2
	constant integer fd = fc * 1000 + 3
	constant integer gd = fc * 1000 + 4
	constant integer hd = fc * 1000 + 5
	constant integer id = fc * 1000 + 6
	constant integer jd = fc * 1000 + 7
	constant integer kd = fc * 1000 + 8
	constant integer ld = fc * 1000 + 9
	constant integer md = fc * 1000 + 10
	constant integer nd = gc * 1000 + 0
	constant integer od = gc * 1000 + 1
	constant integer pd = gc * 1000 + 2
	constant integer qd = gc * 1000 + 3
	constant integer rd = gc * 1000 + 4
	constant integer sd = gc * 1000 + 5
	constant integer td = gc * 1000 + 6
	constant integer ud = gc * 1000 + 7
	constant integer vd = gc * 1000 + 8
	constant integer wd = gc * 1000 + 9
	constant integer xd = hc * 1000 + 0
	constant integer yd = hc * 1000 + 1
	constant integer zd = hc * 1000 + 2
	constant integer Ad = hc * 1000 + 3
	constant integer Bd = hc * 1000 + 4
	constant integer Cd = hc * 1000 + 5
	constant integer Dd = hc * 1000 + 6
	constant integer Ed = hc * 1000 + 7
	constant integer Fd = hc * 1000 + 8
	constant integer Gd = hc * 1000 + 9
	constant integer Hd = hc * 1000 + 10
	constant integer Id = hc * 1000 + 11
	constant integer Jd = hc * 1000 + 12
	constant integer Kd = hc * 1000 + 13
	constant integer Ld = ic * 1000 + 0
	constant integer Md = 0
	constant integer Nd = 1
	constant integer Od = 2
	constant integer Pd = 3
	constant integer Qd = 4
	constant integer Rd = 5
	constant integer Sd = 6
	constant integer Td = 7
	constant integer Ud = 8
	constant integer Vd = 9
	constant integer Wd = 10
	constant integer Xd = 0
	constant integer Yd = 1
	constant integer Zd = 2
	constant integer ae = 3
	constant integer be = 4
	constant integer ce = 5
	constant integer de = 6
	constant integer ee = 7
	constant integer fe = 0
	constant integer ge = 1
	constant integer he = 0
	constant integer ie = 1
	constant integer je = 2
	constant integer ke = 3
	constant integer le = 0
	constant integer me = 1
	constant integer ne = 2
	constant integer oe = 0
	constant integer pe = 1
	constant integer qe = 0
	constant integer re = 1
	constant integer se = 2
	constant integer te = 3
	constant integer ue = 0
	constant integer ve = 1
	constant integer we = 2
	constant integer xe = 3
	constant integer ye = 4
	constant integer ze = 5
	constant integer Ae = 6
	constant integer Be = 7
	constant integer Ce = 8
	constant integer De = 9
	constant integer Ee = 10
	constant integer Fe = 11
	constant integer Ge = 12
	constant integer He = 0
	constant integer Ie = 1
	constant integer Je = 2
	constant integer Ke = 0
	constant integer Le = 1
	constant integer Me = 2
	constant integer Ne = 0
	constant integer Oe = 1
	constant integer Pe = 2
	constant integer Qe = 3
	constant integer Re = 0
	constant integer Se = 1
	constant integer Te = 2
	constant integer Ue = 0
	constant integer Ve = 1
	constant integer We = 2
	constant integer Xe = 3
	constant integer Ye = 0
	constant integer Ze = 1
	constant integer af = 2
	constant integer bf = 0
	constant integer cf = 1
	constant integer df = 2
	constant integer ef = 0
	constant integer ff = 1
	constant integer gf = 2
	constant integer hf = 3
	constant integer jf = 0
	constant integer kf = 1
	constant integer lf = 2
	constant integer mf = 0
	constant integer nf = 1
	constant integer of = 2
	constant integer pf = 3
	constant integer qf = 4
	constant integer rf = 0
	constant integer sf = 1
	constant integer tf = 2
	constant integer uf = 3
	constant integer vf = 4
	constant integer wf = 0
	constant integer xf = 1
	constant integer yf = 2
	constant integer zf = 3
	constant integer Af = 4
	constant integer Bf = 5
	constant integer Cf = 0
	constant integer Df = 1
	constant integer Ef = 2
	constant integer Ff = 0
	constant integer Gf = 1
	constant integer Hf = 2
	constant real If = 8.00
	constant integer Jf = 0
	constant integer Kf = 1
	constant integer Lf = 'DTep'
	constant integer Mf = 'DTrf'
	constant integer Nf = 'DTrx'
	constant integer Of = 0
	constant integer Pf = 1
	constant integer Qf = 2
	constant integer Rf = 3
	constant integer Sf = 4
	force Tf = null
	force array Uf
	integer Vf = 0
	rect Wf = null
	rect Xf = null
	integer Yf = 0
	integer Zf = 0
	integer ag = 0
	integer bg = 0
	boolean cg = false
	boolean array dg
	mapcontrol array eg
	timer fg = null
	boolean gg = false
	timer hg = CreateTimer()
	boolean ig = false
	trigger jg = null
	trigger kg = null
	sound lg = null
	sound mg = null
	trigger ng = null
	trigger og = null
	sound pg = null
	sound qg = null
	boolean rg = true
	boolean sg = false
	sound tg = null
	sound ug = null
	sound vg = null
	sound wg = null
	sound xg = null
	sound yg = null
	sound zg = null
	sound Ag = null
	sound Bg = null
	sound Cg = null
	sound Dg = null
	trigger Eg = null
	timer Fg = null
	boolean array Gg
	boolean array Hg
	boolean array Ig
	integer Jg = 0
	itemtype Kg
	trigger Lg = null
	boolean Mg = true
	boolean Ng = false
	location Og = null
	unit Pg = null
	real Qg = 0.00
	boolean Rg = false
	boolean array Sg
	boolean array Tg
	unit array Ug
	timer array Vg
	timerdialog array Wg
	boolean array Xg
	boolean array Yg
	boolean Zg = false
	timerdialog ah = null
	integer array bh
	trigger ch = null
	boolean dh = true
	boolean eh = true
	timer fh = null
	sound gh = null
	trigger hh = null
	gamespeed ih = 
	boolean jh = false
	boolean kh = false
	boolean lh = false
	boolean mh = false
	integer nh = 0
	timer oh = null
	timer ph = null
	real qh = 0
	real rh = 0
	real sh = 0
	real th = 0
	real uh = 0
	string vh = ""
	integer wh = 0
	trigger array xh
	boolean array yh
	timer zh = CreateTimer()
	trigger Ah = null
	integer Bh = 0
	trigger Ch = null
	integer Dh = 0
	integer Eh = 0
	integer Fh = 0
	player Gh = null
	group Hh = null
	group Ih = null
	integer Jh = 0
	unit Kh = null
	group Lh = null
	group Mh = null
	integer Nh = 0
	integer Oh = 0
	real Ph = 0
	integer Qh = 0
	destructable Rh = null
	destructable Sh = null
	destructable Th = null
	integer Uh = 0
	item Vh = null
	integer Wh = 0
	player Xh = null
	unit Yh = null
	boolean Zh = true
	boolean ai = true
	location bi = null
	real ci = 0
	playercolor di = null
	boolean ei = true
	boolean fi = true
	boolean gi = true
	rect hi = null
	boolean ii = false
	string ji = null
	group ki = CreateGroup()
	group li = CreateGroup()
	timer mi = CreateTimer()
	trigger ni = null
	integer oi = 0
	widget pi = null
	integer qi = 0
	integer array ri
	integer array si
	unit ti = null
	item ui = null
	item vi = null
	unit wi = null
	destructable xi = null
	group yi = CreateGroup()
	fogmodifier zi = null
	effect Ai = null
	weathereffect Bi = null
	terraindeformation Ci = null
	quest Di = null
	questitem Ei = null
	defeatcondition Fi = null
	timer Gi = CreateTimer()
	timerdialog Hi = null
	leaderboard Ii = null
	multiboard Ji = null
	sound Ki = null
	string Li = ""
	real Mi = 0
	gamecache Ni = null
	hashtable Oi = null
	unit Pi = null
	button Qi = null
	unit Ri = null
	texttag Si = null
	lightning Ti = null
	image Ui = null
	ubersplat Vi = null
	boolexpr Wi = null
	boolexpr Xi = null
	boolexpr Yi = null
	boolexpr Zi = null
	boolexpr aj = null
	boolexpr bj = null
	boolexpr cj = null
	boolean dj = false
endglobals

function ej takes string gj returns nothing
	local integer fj = 0
	loop
		call (Player(fj), 0, 0, 60, gj)
		set fj = fj + 1
		exitwhen fj == D
	endloop
endfunction

function hj takes real jj, real ij returns real
	if (jj < ij) then
		return jj
	else
		return ij
	endif
endfunction

function kj takes real mj, real lj returns real
	if (mj < lj) then
		return lj
	else
		return mj
	endif
endfunction

function nj takes real oj returns real
	if (oj >= 0) then
		return oj
	else
		return -oj
	endif
endfunction

function pj takes real qj returns real
	if (qj >= 0.0) then
		return 1.0
	else
		return -1.0
	endif
endfunction

function rj takes integer tj, integer sj returns integer
	if (tj < sj) then
		return tj
	else
		return sj
	endif
endfunction

function uj takes integer wj, integer vj returns integer
	if (wj < vj) then
		return vj
	else
		return wj
	endif
endfunction

function xj takes integer yj returns integer
	if (yj >= 0) then
		return yj
	else
		return -yj
	endif
endfunction

function zj takes integer Aj returns integer
	if (Aj >= 0) then
		return 1
	else
		return -1
	endif
endfunction

function Bj takes real Cj returns real
	return Sin(Cj * g)
endfunction

function Dj takes real Ej returns real
	return Cos(Ej * g)
endfunction

function Fj takes real Gj returns real
	return Tan(Gj * g)
endfunction

function Hj takes real Ij returns real
	return Asin(Ij) * f
endfunction

function Jj takes real Kj returns real
	return Acos(Kj) * f
endfunction

function Lj takes real Mj returns real
	return Atan(Mj) * f
endfunction

function Nj takes real Pj, real Oj returns real
	return Atan2(Pj, Oj) * f
endfunction

function Qj takes location Sj, location Rj returns real
	return f * Atan2(GetLocationY(Rj) - GetLocationY(Sj), GetLocationX(Rj) - GetLocationX(Sj))
endfunction

function Tj takes location Xj, location Wj returns real
	local real Vj = GetLocationX(Wj) - GetLocationX(Xj)
	local real Uj = GetLocationY(Wj) - GetLocationY(Xj)
	return SquareRoot(Vj * Vj + Uj * Uj)
endfunction

function Yj takes location dk, real ck, real bk returns location
	local real ak = GetLocationX(dk) + ck * Cos(bk * g)
	local real Zj = GetLocationY(dk) + ck * Sin(bk * g)
	return Location(ak, Zj)
endfunction

function ek takes nothing returns real
	return GetRandomReal(0, 360)
endfunction

function fk takes nothing returns real
	return GetRandomReal(0, 100)
endfunction

function gk takes rect hk returns location
	return Location(GetRandomReal(GetRectMinX(hk), GetRectMaxX(hk)), GetRandomReal(GetRectMinY(hk), GetRectMaxY(hk)))
endfunction

function ik takes integer lk, integer kk returns integer
	local integer jk = lk - (lk / kk) * kk
	if (jk < 0) then
		set jk = jk + kk
	endif
	return jk
endfunction

function mk takes real pk, real ok returns real
	local real nk = pk - I2R(R2I(pk / ok)) * ok
	if (nk < 0) then
		set nk = nk + ok
	endif
	return nk
endfunction

function qk takes location tk, real sk, real rk returns location
	return Location(GetLocationX(tk) + sk, GetLocationY(tk) + rk)
endfunction

function uk takes rect xk, real wk, real vk returns rect
	return Rect(GetRectMinX(xk) + wk, GetRectMinY(xk) + vk, GetRectMaxX(xk) + wk, GetRectMaxY(xk) + vk)
endfunction

function yk takes location Dk, real Ck, real Bk returns rect
	local real Ak = GetLocationX(Dk)
	local real zk = GetLocationY(Dk)
	return Rect(Ak - Ck * 0.5, zk - Bk * 0.5, Ak + Ck * 0.5, zk + Bk * 0.5)
endfunction

function Ek takes rect Hk, real Gk, real Fk returns boolean
	return (GetRectMinX(Hk) <= Gk) and (Gk <= GetRectMaxX(Hk)) and (GetRectMinY(Hk) <= Fk) and (Fk <= GetRectMaxY(Hk))
endfunction

function Ik takes rect Kk, location Jk returns boolean
	return Ek(Kk, GetLocationX(Jk), GetLocationY(Jk))
endfunction

function Lk takes rect Nk, unit Mk returns boolean
	return Ek(Nk, GetUnitX(Mk), GetUnitY(Mk))
endfunction

function Ok takes item Qk, rect Pk returns boolean
	if (Qk == null) then
		return false
	endif
	if (IsItemOwned(Qk)) then
		return false
	endif
	return Ek(Pk, GetItemX(Qk), GetItemY(Qk))
endfunction

function Rk takes trigger Sk returns nothing
	if TriggerEvaluate(Sk) then
		call (Sk)
	endif
endfunction

function Tk takes trigger Vk, boolean Uk returns boolean
	if Uk then
		if not (TriggerEvaluate(Vk)) then
			return false
		endif
	endif
	call (Vk)
	return true
endfunction

function Wk takes trigger Yk, boolean Xk returns boolean
	if Xk then
		if not (TriggerEvaluate(Yk)) then
			return false
		endif
	endif
	call (Yk, 0, false)
	return true
endfunction

function Zk takes nothing returns nothing
	local string bl = "TrigQueue Check "
	local integer al
	set al = 0
	loop
		exitwhen al >= wh
		set bl = bl + "q[" + I2S(al) + "]="
		if (xh[al] == null) then
			set bl = bl + "null "
		else
			set bl = bl + "x "
		endif
		set al = al + 1
	endloop
	set bl = bl + "(" + I2S(wh) + " total)"
	call (GetLocalPlayer(), 0, 0, 600, bl)
endfunction

function cl takes trigger el returns integer
	local integer dl = 0
	loop
		exitwhen dl >= wh
		if (xh[dl] == el) then
			return dl
		endif
		set dl = dl + 1
	endloop
	return -1
endfunction

function fl takes integer hl returns boolean
	local integer gl
	if (hl >= wh) then
		return false
	endif
	set wh = wh - 1
	set gl = hl
	loop
		exitwhen gl >= wh
		set xh[gl] = xh[gl + 1]
		set yh[gl] = yh[gl + 1]
		set gl = gl + 1
	endloop
	return true
endfunction

function il takes nothing returns boolean
	loop
		exitwhen wh == 0
		if Tk(xh[0], yh[0]) then
			call (zh, Qb, false, null)
			return true
		endif
		call fl(0)
	endloop
	return false
endfunction

function jl takes trigger ll, boolean kl returns boolean
	if (wh >= Pb) then
		return false
	endif
	set xh[wh] = ll
	set yh[wh] = kl
	set wh = wh + 1
	if (wh == 1) then
		call il()
	endif
	return true
endfunction

function ml takes trigger ql returns nothing
	local integer pl
	local integer ol
	local boolean nl
	set ol = cl(ql)
	if (ol == -1) then
		return
	endif
	call fl(ol)
	if (ol == 0) then
		call (zh)
		call il()
	endif
endfunction

function rl takes nothing returns nothing
	local integer sl
	if (wh <= 0) then
		return
	endif
	call fl(0)
	call (zh)
	call il()
endfunction

function tl takes nothing returns nothing
	call (zh)
	set wh = 0
endfunction

function ul takes nothing returns nothing
	set wh = rj(wh, 1)
endfunction

function vl takes nothing returns integer
	return wh
endfunction

function wl takes nothing returns boolean
	return wh <= 0
endfunction

function xl takes trigger yl returns boolean
	return cl(yl) != -1
endfunction

function zl takes nothing returns integer
	return Yf
endfunction

function Al takes integer Bl returns nothing
	set Yf = Bl
endfunction

function Cl takes nothing returns integer
	return Zf
endfunction

function Dl takes integer El returns nothing
	set Zf = El
endfunction

function Fl takes real Il returns nothing
	local timer Hl
	local real Gl
	if (Il > 0) then
		set Hl = CreateTimer()
		call (Hl, Il, false, null)
		loop
			set Gl = TimerGetRemaining(Hl)
			exitwhen Gl <= 0
			if (Gl > B) then
				call (0.1 * Gl)
			else
				call (A)
			endif
		endloop
		call (Hl)
	endif
endfunction

function Jl takes boolean Ml, integer Ll, integer Kl returns integer
	if Ml then
		return Ll
	else
		return Kl
	endif
endfunction

function Nl takes nothing returns nothing
endfunction

function Ol takes string Pl returns nothing
endfunction

function Ql takes string Rl returns string
	return GetLocalizedString(Rl)
endfunction

function Sl takes boolean Ul, boolean Tl returns boolean
	return Ul and Tl
endfunction

function Vl takes boolean Xl, boolean Wl returns boolean
	return Xl or Wl
endfunction

function Yl takes real bm, integer am returns integer
	local integer Zl = R2I(bm * I2R(am) * 0.01)
	if (Zl < 0) then
		set Zl = 0
	elseif (Zl < 0) then
		set Zl = am
	endif
	return Zl
endfunction

function cm takes real dm returns integer
	return Yl(dm, 255)
endfunction

function em takes nothing returns real
	return GetFloatGameState()
endfunction

function fm takes real gm returns nothing
	call (, gm)
endfunction

function hm takes real im returns nothing
	call (im * 0.01)
endfunction

function jm takes nothing returns real
	return GetTimeOfDayScale() * 100
endfunction

function km takes string mm returns nothing
	local sound lm = CreateSound(mm, false, false, true, 12700, 12700, "")
	call (lm)
	call (lm)
endfunction

function nm takes location pm, location om returns boolean
	return GetLocationX(pm) == GetLocationX(om) and GetLocationY(pm) == GetLocationY(om)
endfunction

function qm takes rect sm, rect rm returns boolean
	return GetRectMinX(sm) == GetRectMinX(rm) and GetRectMinY(sm) == GetRectMinY(rm) and GetRectMaxX(sm) == GetRectMaxX(rm) and GetRectMaxY(sm) == GetRectMaxY(rm)
endfunction

function tm takes location xm, real wm returns rect
	local real vm = GetLocationX(xm)
	local real um = GetLocationY(xm)
	return Rect(vm - wm, um - wm, vm + wm, um + wm)
endfunction

function ym takes nothing returns camerasetup
	local camerasetup Am = CreateCameraSetup()
	local real zm = 0
	call (Am, , GetCameraField(), zm)
	call (Am, , GetCameraField(), zm)
	call (Am, , GetCameraField(), zm)
	call (Am, , f * GetCameraField(), zm)
	call (Am, , f * GetCameraField(), zm)
	call (Am, , f * GetCameraField(), zm)
	call (Am, , f * GetCameraField(), zm)
	call (Am, GetCameraTargetPositionX(), GetCameraTargetPositionY(), zm)
	return Am
endfunction

function Bm takes boolean Fm, camerasetup Em, player Dm, real Cm returns nothing
	if (GetLocalPlayer() == Dm) then
		call (Em, Fm, Cm)
	endif
endfunction

function Gm takes camerafield Im, camerasetup Hm returns real
	return CameraSetupGetField(Hm, Im)
endfunction

function Jm takes player Nm, camerafield Mm, real Lm, real Km returns nothing
	if (GetLocalPlayer() == Nm) then
		call (Mm, Lm, Km)
	endif
endfunction

function Om takes player Tm, unit Sm, real Rm, real Qm, boolean Pm returns nothing
	if (GetLocalPlayer() == Tm) then
		call (Sm, Rm, Qm, Pm)
	endif
endfunction

function Um takes player Xm, real Wm, real Vm returns nothing
	if (GetLocalPlayer() == Xm) then
		call (Wm, Vm)
	endif
endfunction

function Ym takes player an, location Zm returns nothing
	if (GetLocalPlayer() == an) then
		call (GetLocationX(Zm), GetLocationY(Zm))
	endif
endfunction

function bn takes real fn, location en, player dn, real cn returns nothing
	if (GetLocalPlayer() == dn) then
		call (GetLocationX(en), GetLocationY(en), g * fn, cn)
	endif
endfunction

function gn takes player kn, real jn, real hn returns nothing
	if (GetLocalPlayer() == kn) then
		call (jn, hn)
	endif
endfunction

function ln takes player nn, location mn returns nothing
	if (GetLocalPlayer() == nn) then
		call (GetLocationX(mn), GetLocationY(mn))
	endif
endfunction

function on takes player sn, real rn, real qn, real pn returns nothing
	if (GetLocalPlayer() == sn) then
		call (rn, qn, pn)
	endif
endfunction

function tn takes player wn, location vn, real un returns nothing
	if (GetLocalPlayer() == wn) then
		call (GetLocationX(vn), GetLocationY(vn), un)
	endif
endfunction

function xn takes player Bn, location An, real zn, real yn returns nothing
	if (GetLocalPlayer() == Bn) then
		call (GetLocationX(An), GetLocationY(An), zn, yn)
	endif
endfunction

function Cn takes player Gn, location Fn, real En returns nothing
	local real Dn
	if (GetLocalPlayer() == Gn) then
		set Dn = Tj(Fn, GetCameraTargetPositionLoc())
		if (Dn >= Ob) then
			call (GetLocationX(Fn), GetLocationY(Fn), 0)
		elseif (Dn >= Ob) then
			call (GetLocationX(Fn), GetLocationY(Fn), En)
		else
		endif
	endif
endfunction

function Hn takes player Jn, string In returns nothing
	if (GetLocalPlayer() == Jn) then
		call (In)
	endif
endfunction

function Kn takes player Mn, real Ln returns nothing
	if (GetLocalPlayer() == Mn) then
		call (Ln)
	endif
endfunction

function Nn takes player Qn, real Pn, real On returns nothing
	if (GetLocalPlayer() == Qn) then
		call (Pn, On)
	endif
endfunction

function Rn takes player Un, real Tn, real Sn returns nothing
	if (GetLocalPlayer() == Un) then
		call (Tn, Sn)
	endif
endfunction

function Vn takes player Yn, real Xn returns nothing
	local real Wn = Xn
	if (Wn > 5.0) then
		set Wn = 5.0
	endif
	if (Wn < 2.0) then
		set Wn = 2.0
	endif
	if (GetLocalPlayer() == Yn) then
		call (Xn * 2.0, Xn * Pow(10, Wn), true)
		call (Xn * 2.0, Xn * Pow(10, Wn), true)
	endif
endfunction

function Zn takes player ao returns nothing
	if (GetLocalPlayer() == ao) then
		call (0, 0)
		call (0, 0)
	endif
endfunction

function bo takes nothing returns rect
	return Rect(GetCameraBoundMinX(), GetCameraBoundMinY(), GetCameraBoundMaxX(), GetCameraBoundMaxY())
endfunction

function co takes nothing returns rect
	return Xf
endfunction

function eo takes nothing returns rect
	return Wf
endfunction

function fo takes nothing returns rect
	return GetWorldBounds()
endfunction

function go takes rect lo returns nothing
	local real ko = GetRectMinX(lo)
	local real jo = GetRectMinY(lo)
	local real io = GetRectMaxX(lo)
	local real ho = GetRectMaxY(lo)
	call (ko, jo, ko, ho, io, ho, io, jo)
endfunction

function mo takes player oo, rect no returns nothing
	if (GetLocalPlayer() == oo) then
		call go(no)
	endif
endfunction

function po takes integer zo, real yo, real xo, real wo, real vo returns nothing
	local real uo = 0
	local real to = 0
	local real so = 0
	local real ro = 0
	local real qo = 0
	if (zo == oe) then
		set qo = 1
	elseif (zo == oe) then
		set qo = -1
	else
		return
	endif
	set uo = GetCameraBoundMinX() - qo * yo
	set so = GetCameraBoundMaxX() + qo * xo
	set to = GetCameraBoundMinY() - qo * vo
	set ro = GetCameraBoundMaxY() + qo * wo
	if (so < uo) then
		set uo = (uo + so) * 0.5
		set so = uo
	endif
	if (ro < to) then
		set to = (to + ro) * 0.5
		set ro = to
	endif
	call (uo, to, uo, ro, so, ro, so, to)
endfunction

function Ao takes integer Go, player Fo, real Eo, real Do, real Co, real Bo returns nothing
	if (GetLocalPlayer() == Fo) then
		call po(Go, Eo, Do, Co, Bo)
	endif
endfunction

function Ho takes player Ko, real Jo, real Io returns nothing
	if (GetLocalPlayer() == Ko) then
		call (Jo, Io)
	endif
endfunction

function Lo takes player No, location Mo returns nothing
	if (GetLocalPlayer() == No) then
		call (GetLocationX(Mo), GetLocationY(Mo))
	endif
endfunction

function Oo takes location Po returns nothing
	call (GetLocationX(Po), GetLocationY(Po))
endfunction

function Qo takes player Ro returns nothing
	if (GetLocalPlayer() == Ro) then
		call ()
	endif
endfunction

function So takes player Wo, unit Vo, real Uo, real To returns nothing
	if (GetLocalPlayer() == Wo) then
		call (Vo, Uo, To)
	endif
endfunction

function Xo takes real Yo returns nothing
	call (Yo)
endfunction

function Zo takes nothing returns nothing
	call (0)
endfunction

function ap takes force cp, string bp returns nothing
	if (IsPlayerInForce(GetLocalPlayer(), cp)) then
		call (GetLocalPlayer(), 0, 0, bp)
	endif
endfunction

function dp takes force gp, real fp, string ep returns nothing
	if (IsPlayerInForce(GetLocalPlayer(), gp)) then
		call (GetLocalPlayer(), 0, 0, fp, ep)
	endif
endfunction

function hp takes force ip returns nothing
	if (IsPlayerInForce(GetLocalPlayer(), ip)) then
		call ()
	endif
endfunction

function jp takes string mp, integer lp, integer kp returns string
	return SubString(mp, lp - 1, kp)
endfunction

function np takes handle op returns integer
	return GetHandleId(op)
endfunction

function pp takes string qp returns integer
	return StringHash(qp)
endfunction

function rp takes trigger tp, real sp returns event
	return TriggerRegisterTimerEvent(tp, sp, true)
endfunction

function up takes trigger wp, real vp returns event
	return TriggerRegisterTimerEvent(wp, vp, false)
endfunction

function xp takes trigger zp, timer yp returns event
	return TriggerRegisterTimerExpireEvent(zp, yp)
endfunction

function Ap takes trigger Dp, player Cp, playerunitevent Bp returns event
	return TriggerRegisterPlayerUnitEvent(Dp, Cp, Bp, null)
endfunction

function Ep takes trigger Hp, playerunitevent Gp returns nothing
	local integer Fp
	set Fp = 0
	loop
		call (Hp, Player(Fp), Gp, null)
		set Fp = Fp + 1
		exitwhen Fp == G
	endloop
endfunction

function Ip takes trigger Lp, player Kp, boolean Jp returns event
	if Jp then
		return TriggerRegisterPlayerUnitEvent(Lp, Kp, , null)
	else
		return TriggerRegisterPlayerUnitEvent(Lp, Kp, , null)
	endif
endfunction

function Mp takes trigger Qp, player Pp, integer Op, integer Np returns event
	if (Op == fe) then
		if (Np == he) then
			return TriggerRegisterPlayerEvent(Qp, Pp, )
		elseif (Np == he) then
			return TriggerRegisterPlayerEvent(Qp, Pp, )
		elseif (Np == he) then
			return TriggerRegisterPlayerEvent(Qp, Pp, )
		elseif (Np == he) then
			return TriggerRegisterPlayerEvent(Qp, Pp, )
		else
			return null
		endif
	elseif (Op == fe) then
		if (Np == he) then
			return TriggerRegisterPlayerEvent(Qp, Pp, )
		elseif (Np == he) then
			return TriggerRegisterPlayerEvent(Qp, Pp, )
		elseif (Np == he) then
			return TriggerRegisterPlayerEvent(Qp, Pp, )
		elseif (Np == he) then
			return TriggerRegisterPlayerEvent(Qp, Pp, )
		else
			return null
		endif
	else
		return null
	endif
endfunction

function Rp takes trigger Tp, player Sp returns event
	return TriggerRegisterPlayerEvent(Tp, Sp, )
endfunction

function Up takes trigger Wp, player Vp returns event
	return TriggerRegisterPlayerEvent(Wp, Vp, )
endfunction

function Xp takes trigger Zp, player Yp returns event
	return TriggerRegisterPlayerEvent(Zp, Yp, )
endfunction

function aq takes trigger cq, player bq returns event
	return TriggerRegisterPlayerEvent(cq, bq, )
endfunction

function dq takes trigger fq, player eq returns event
	return TriggerRegisterPlayerEvent(fq, eq, )
endfunction

function gq takes trigger jq, limitop iq, real hq returns event
	return TriggerRegisterGameStateEvent(jq, , iq, hq)
endfunction

function kq takes trigger mq, region lq returns event
	return TriggerRegisterEnterRegion(mq, lq, null)
endfunction

function nq takes trigger pq, region oq returns event
	return TriggerRegisterLeaveRegion(pq, oq, null)
endfunction

function qq takes trigger tq, rect sq returns event
	local region rq = CreateRegion()
	call (rq, sq)
	return TriggerRegisterEnterRegion(tq, rq, null)
endfunction

function uq takes trigger xq, rect wq returns event
	local region vq = CreateRegion()
	call (vq, wq)
	return TriggerRegisterLeaveRegion(xq, vq, null)
endfunction

function yq takes trigger Cq, unit Bq, boolexpr Aq, real zq returns event
	return TriggerRegisterUnitInRange(Cq, Bq, zq, Aq)
endfunction

function Dq takes trigger Gq, real Fq, unit Eq returns event
	return TriggerRegisterUnitInRange(Gq, Eq, Fq, null)
endfunction

function Hq takes trigger Lq, unit Kq, limitop Jq, real Iq returns event
	return TriggerRegisterUnitStateEvent(Lq, Kq, , Jq, Iq)
endfunction

function Mq takes trigger Qq, unit Pq, limitop Oq, real Nq returns event
	return TriggerRegisterUnitStateEvent(Qq, Pq, , Oq, Nq)
endfunction

function Rq takes trigger Tq, dialog Sq returns event
	return TriggerRegisterDialogEvent(Tq, Sq)
endfunction

function Uq takes trigger Vq returns event
	return TriggerRegisterGameEvent(Vq, )
endfunction

function Wq takes trigger Xq returns event
	return TriggerRegisterGameEvent(Xq, )
endfunction

function Yq takes trigger Zq returns event
	return TriggerRegisterGameEvent(Zq, )
endfunction

function ar takes trigger br returns event
	return TriggerRegisterGameEvent(br, )
endfunction

function cr takes nothing returns nothing
	set Bh = Bh + 1
	if (Bh <= fb) then
		call (Ch, GetEnumDestructable())
	endif
endfunction

function dr takes trigger fr, rect er returns nothing
	set Ch = fr
	set Bh = 0
	call (er, null, function )
endfunction

function gr takes rect ir, integer hr returns weathereffect
	set Bi = AddWeatherEffect(ir, hr)
	return Bi
endfunction

function jr takes nothing returns weathereffect
	return Bi
endfunction

function kr takes weathereffect lr returns nothing
	call (lr)
endfunction

function mr takes real sr, boolean rr, location qr, real pr, real nr returns terraindeformation
	set Ci = TerrainDeformCrater(GetLocationX(qr), GetLocationY(qr), pr, nr, R2I(sr * 1000), rr)
	return Ci
endfunction

function tr takes real Er, boolean Dr, location Cr, real Br, real Ar, real zr, real yr, real xr returns terraindeformation
	local real wr
	local real vr
	local real ur
	if (Ar <= 0 or xr <= 0 or yr <= 0) then
		return null
	endif
	set vr = 2.0 * Er / yr
	set wr = 2.0 * Ar / xr
	set ur = Br / Ar
	set Ci = TerrainDeformRipple(GetLocationX(Cr), GetLocationY(Cr), Ar, zr, R2I(Er * 1000), 1, wr, vr, ur, Dr)
	return Ci
endfunction

function Fr takes real Qr, location Pr, location Nr, real Mr, real Lr, real Kr returns terraindeformation
	local real Jr
	local real Ir
	local real Hr
	local real Gr
	set Jr = Tj(Pr, Nr)
	if (Jr == 0 or Qr <= 0) then
		return null
	endif
	set Ir = (GetLocationX(Nr) - GetLocationX(Pr)) / Jr
	set Hr = (GetLocationY(Nr) - GetLocationY(Pr)) / Jr
	set Gr = Jr / Qr
	set Ci = TerrainDeformWave(GetLocationX(Pr), GetLocationY(Pr), Ir, Hr, Jr, Gr, Mr, Lr, R2I(Kr * 1000), 1)
	return Ci
endfunction

function Rr takes real Xr, location Wr, real Vr, real Ur, real Tr, real Sr returns terraindeformation
	set Ci = TerrainDeformRandom(GetLocationX(Wr), GetLocationY(Wr), Vr, Ur, Tr, R2I(Xr * 1000), R2I(Sr * 1000))
	return Ci
endfunction

function Yr takes terraindeformation as, real Zr returns nothing
	call (as, R2I(Zr * 1000))
endfunction

function bs takes nothing returns terraindeformation
	return Ci
endfunction

function cs takes string fs, location es, location ds returns lightning
	set Ti = AddLightningEx(fs, true, GetLocationX(es), GetLocationY(es), GetLocationZ(es), GetLocationX(ds), GetLocationY(ds), GetLocationZ(ds))
	return Ti
endfunction

function gs takes lightning hs returns boolean
	return DestroyLightning(hs)
endfunction

function is takes lightning ls, location ks, location js returns boolean
	return MoveLightningEx(ls, true, GetLocationX(ks), GetLocationY(ks), GetLocationZ(ks), GetLocationX(js), GetLocationY(js), GetLocationZ(js))
endfunction

function ms takes lightning ns returns real
	return GetLightningColorA(ns)
endfunction

function os takes lightning ps returns real
	return GetLightningColorR(ps)
endfunction

function qs takes lightning rs returns real
	return GetLightningColorG(rs)
endfunction

function ss takes lightning ts returns real
	return GetLightningColorB(ts)
endfunction

function us takes lightning zs, real ys, real xs, real ws, real vs returns boolean
	return SetLightningColor(zs, ys, xs, ws, vs)
endfunction

function As takes nothing returns lightning
	return Ti
endfunction

function Bs takes integer Es, effecttype Ds, integer Cs returns string
	return GetAbilityEffectById(Es, Ds, Cs)
endfunction

function Fs takes integer Hs, soundtype Gs returns string
	return GetAbilitySoundById(Hs, Gs)
endfunction

function Is takes location Js returns integer
	return GetTerrainCliffLevel(GetLocationX(Js), GetLocationY(Js))
endfunction

function Ks takes location Ls returns integer
	return GetTerrainType(GetLocationX(Ls), GetLocationY(Ls))
endfunction

function Ms takes location Ns returns integer
	return GetTerrainVariance(GetLocationX(Ns), GetLocationY(Ns))
endfunction

function Os takes location Ts, integer Ss, integer Rs, integer Qs, integer Ps returns nothing
	call (GetLocationX(Ts), GetLocationY(Ts), Ss, Rs, Qs, Ps)
endfunction

function Us takes location Ws, pathingtype Vs returns boolean
	return IsTerrainPathable(GetLocationX(Ws), GetLocationY(Ws), Vs)
endfunction

function Xs takes location at, pathingtype Zs, boolean Ys returns nothing
	call (GetLocationX(at), GetLocationY(at), Zs, Ys)
endfunction

function bt takes real ft, real et, real dt, real ct returns nothing
	call (cm(ft), cm(et), cm(dt), cm(100.0 - ct))
endfunction

function gt takes player kt, fogstate jt, rect it, boolean ht returns fogmodifier
	set zi = CreateFogModifierRect(kt, jt, it, true, ht)
	return zi
endfunction

function lt takes player qt, fogstate pt, location ot, real nt, boolean mt returns fogmodifier
	set zi = CreateFogModifierRadiusLoc(qt, pt, ot, nt, true, mt)
	return zi
endfunction

function rt takes boolean vt, player ut, fogstate tt, rect st returns fogmodifier
	set zi = CreateFogModifierRect(ut, tt, st, true, false)
	if vt then
		call (zi)
	endif
	return zi
endfunction

function wt takes boolean Bt, player At, fogstate zt, location yt, real xt returns fogmodifier
	set zi = CreateFogModifierRadiusLoc(At, zt, yt, xt, true, false)
	if Bt then
		call (zi)
	endif
	return zi
endfunction

function Ct takes nothing returns fogmodifier
	return zi
endfunction

function Dt takes nothing returns nothing
	call (true)
endfunction

function Et takes nothing returns nothing
	call (false)
endfunction

function Ft takes nothing returns nothing
	call (true)
endfunction

function Gt takes nothing returns nothing
	call (false)
endfunction

function Ht takes boolean It returns nothing
	call (not It)
endfunction

function Jt takes integer Qt, real Pt, real Ot, real Nt, real Mt, real Lt, real Kt returns nothing
	call (Qt, Pt, Ot, Nt, Mt * 0.01, Lt * 0.01, Kt * 0.01)
endfunction

function Rt takes nothing returns nothing
	call ()
endfunction

function St takes string Wt, integer Vt, real Ut, location Tt returns nothing
	call (GetLocationX(Tt), GetLocationY(Tt), Ut, Vt, false, Wt, false)
endfunction

function Xt takes string au, integer Zt, rect Yt returns nothing
	call (Yt, Zt, au, false)
endfunction

function bu takes boolean eu, string du, unit cu returns nothing
	call (cu, du, eu)
endfunction

function fu takes string ku, real ju, location iu, real hu, integer gu returns image
	set Ui = CreateImage(ku, ju, ju, ju, GetLocationX(iu), GetLocationY(iu), hu, 0, 0, 0, gu)
	return Ui
endfunction

function lu takes boolean nu, image mu returns nothing
	call (mu, nu)
endfunction

function ou takes image ru, location qu, real pu returns nothing
	call (ru, GetLocationX(qu), GetLocationY(qu), pu)
endfunction

function su takes image xu, real wu, real vu, real uu, real tu returns nothing
	call (xu, cm(wu), cm(vu), cm(uu), cm(100.0 - tu))
endfunction

function yu takes nothing returns image
	return Ui
endfunction

function zu takes location Hu, string Gu, real Fu, real Eu, real Du, real Cu, boolean Bu, boolean Au returns ubersplat
	set Vi = CreateUbersplat(GetLocationX(Hu), GetLocationY(Hu), Gu, cm(Fu), cm(Eu), cm(Du), cm(100.0 - Cu), Bu, Au)
	return Vi
endfunction

function Iu takes boolean Ku, ubersplat Ju returns nothing
	call (Ju, Ku)
endfunction

function Lu takes nothing returns ubersplat
	return Vi
endfunction

function Mu takes sound Nu returns nothing
	set Ki = Nu
	if (Nu != null) then
		call (Nu)
	endif
endfunction

function Ou takes sound Qu, boolean Pu returns nothing
	call (Qu, false, Pu)
endfunction

function Ru takes sound Tu, real Su returns nothing
	call (Tu, Yl(Su, 127))
endfunction

function Uu takes real Wu, sound Vu returns nothing
	call (Vu, R2I(Wu * 1000))
endfunction

function Xu takes sound Zu, real Yu returns nothing
	call (Zu, Yu)
endfunction

function av takes sound cv, real bv returns nothing
	call (cv, bv)
endfunction

function dv takes sound gv, location fv, real ev returns nothing
	call (gv, GetLocationX(fv), GetLocationY(fv), ev)
endfunction

function hv takes sound jv, unit iv returns nothing
	call (jv, iv)
endfunction

function kv takes sound ov, real nv, real mv, real lv returns nothing
	call (ov, nv, mv, Yl(lv, 127))
endfunction

function pv takes sound qv returns nothing
	call (qv)
endfunction

function rv takes sound vv, real uv, location tv, real sv returns nothing
	call dv(vv, tv, sv)
	call Ru(vv, uv)
	call Mu(vv)
endfunction

function wv takes sound zv, real yv, unit xv returns nothing
	call hv(zv, xv)
	call Ru(zv, yv)
	call Mu(zv)
endfunction

function Av takes sound Dv, real Cv, real Bv returns nothing
	call Ru(Dv, Cv)
	call Mu(Dv)
	call Uu(Bv, Dv)
endfunction

function Ev takes string Fv returns nothing
	set Li = Fv
	call (Fv)
endfunction

function Gv takes string Jv, real Iv, real Hv returns nothing
	set Li = Jv
	call (Jv, R2I(Iv * 1000), R2I(Hv * 1000))
endfunction

function Kv takes real Lv returns nothing
	call (R2I(Lv * 1000))
endfunction

function Mv takes string Nv returns nothing
	call (Nv)
endfunction

function Ov takes string Qv, real Pv returns nothing
	call (Qv, R2I(Pv * 1000))
endfunction

function Rv takes real Sv returns nothing
	call (R2I(Sv * 1000))
endfunction

function Tv takes nothing returns nothing
	call ()
endfunction

function Uv takes boolean Vv returns nothing
	call (Vv)
endfunction

function Wv takes nothing returns nothing
	call ()
endfunction

function Xv takes real Yv returns nothing
	call (Yl(Yv, 127))
endfunction

function Zv takes sound aw returns real
	if (aw == null) then
		return ob
	else
		return I2R(GetSoundDuration(aw)) * 0.001
	endif
endfunction

function bw takes string cw returns real
	return I2R(GetSoundFileDuration(cw)) * 0.001
endfunction

function dw takes nothing returns sound
	return Ki
endfunction

function ew takes nothing returns string
	return Li
endfunction

function fw takes volumegroup hw, real gw returns nothing
	call (hw, gw * 0.01)
endfunction

function iw takes nothing returns nothing
	call (, xb)
	call (, yb)
	call (, zb)
	call (, Ab)
	call (, Bb)
	call (, Cb)
	call (, Db)
	call (, Eb)
endfunction

function jw takes nothing returns nothing
	if gg then
		call iw()
	else
		call (hg, y, false, function )
	endif
endfunction

function kw takes nothing returns nothing
	call (, Fb)
	call (, Gb)
	call (, Hb)
	call (, Ib)
	call (, Jb)
	call (, Kb)
	call (, Lb)
	call (, Mb)
endfunction

function lw takes nothing returns nothing
	if gg then
		call kw()
	else
		call (hg, y, false, function )
	endif
endfunction

function mw takes nothing returns nothing
	call ()
endfunction

function nw takes nothing returns nothing
	if gg then
		call mw()
	else
		call (hg, y, false, function )
	endif
endfunction

function ow takes sound pw returns boolean
	return GetSoundIsLoading(pw) or GetSoundIsPlaying(pw)
endfunction

function qw takes sound sw, real rw returns nothing
	call (sw, rw)
endfunction

function tw takes string vw, integer uw returns nothing
	call (vw, false, uw)
endfunction

function ww takes string xw returns nothing
	call (xw, true, 0)
endfunction

function yw takes nothing returns nothing
	call ()
endfunction

function zw takes boolean Ew, sound Dw, rect Cw returns nothing
	local real Bw = GetRectMaxX(Cw) - GetRectMinX(Cw)
	local real Aw = GetRectMaxY(Cw) - GetRectMinY(Cw)
	call (Dw, GetRectCenterX(Cw), GetRectCenterY(Cw), 0)
	if Ew then
		call (Dw, true, Bw, Aw)
	else
		call (Dw, true, Bw, Aw)
	endif
endfunction

function Fw takes player Hw, sound Gw returns nothing
	if (Hw == GetLocalPlayer()) then
		call (Gw)
	endif
endfunction

function Iw takes player Lw, volumegroup Kw, real Jw returns nothing
	if (GetLocalPlayer() == Lw) then
		call (Kw, Jw)
	endif
endfunction

function Mw takes boolean Nw returns nothing
	set rg = Nw
endfunction

function Ow takes nothing returns boolean
	return rg
endfunction

function Pw takes string Rw returns nothing
	local real Qw
	if (lg != null) then
		call (lg, true, true)
	endif
	set lg = CreateMIDISound(Rw, 20, 20)
	set Qw = em()
	if (Qw >= L and Qw < M) then
		call (lg)
	endif
endfunction

function Sw takes string Uw returns nothing
	local real Tw
	if (mg != null) then
		call (mg, true, true)
	endif
	set mg = CreateMIDISound(Uw, 20, 20)
	set Tw = em()
	if (Tw < L or Tw >= M) then
		call (mg)
	endif
endfunction

function Vw takes location Xw, string Ww returns effect
	set Ai = AddSpecialEffectLoc(Ww, Xw)
	return Ai
endfunction

function Yw takes string bx, widget ax, string Zw returns effect
	set Ai = AddSpecialEffectTarget(Zw, ax, bx)
	return Ai
endfunction

function cx takes effect dx returns nothing
	call (dx)
endfunction

function ex takes nothing returns effect
	return Ai
endfunction

function fx takes item gx returns location
	return Location(GetItemX(gx), GetItemY(gx))
endfunction

function hx takes widget ix returns real
	return GetWidgetLife(ix)
endfunction

function jx takes widget lx, real kx returns nothing
	call (lx, kx)
endfunction

function mx takes integer px, unit ox, boolean nx returns nothing
	call (ox, px, nx)
endfunction

function qx takes unit ux, integer tx, boolean sx returns nothing
	local integer rx = GetHeroLevel(ux)
	if (tx > rx) then
		call (ux, tx, sx)
	elseif (tx > rx) then
		call (ux, rx - tx)
	else
	endif
endfunction

function vx takes integer xx, unit wx returns integer
	return DecUnitAbilityLevel(wx, xx)
endfunction

function yx takes integer Ax, unit zx returns integer
	return IncUnitAbilityLevel(zx, Ax)
endfunction

function Bx takes integer Ex, unit Dx, integer Cx returns integer
	return SetUnitAbilityLevel(Dx, Ex, Cx)
endfunction

function Fx takes integer Hx, unit Gx returns integer
	return GetUnitAbilityLevel(Gx, Hx)
endfunction

function Ix takes unit Kx, integer Jx returns boolean
	return (GetUnitAbilityLevel(Kx, Jx) > 0)
endfunction

function Lx takes integer Nx, unit Mx returns boolean
	return UnitRemoveAbility(Mx, Nx)
endfunction

function Ox takes item Qx, unit Px returns boolean
	return UnitAddItem(Px, Qx)
endfunction

function Rx takes integer Tx, unit Sx returns item
	set ui = CreateItem(Tx, GetUnitX(Sx), GetUnitY(Sx))
	call (Sx, ui)
	return ui
endfunction

function Ux takes item Wx, unit Vx returns nothing
	set vi = Wx
	call (Vx, Wx)
endfunction

function Xx takes integer Zx, unit Yx returns item
	set vi = UnitRemoveItemFromSlot(Yx, Zx - 1)
	return vi
endfunction

function ay takes integer cy, location by returns item
	set ui = CreateItem(cy, GetLocationX(by), GetLocationY(by))
	return ui
endfunction

function dy takes nothing returns item
	return ui
endfunction

function ey takes nothing returns item
	return vi
endfunction

function fy takes item hy, location gy returns nothing
	call (hy, GetLocationX(gy), GetLocationY(gy))
endfunction

function iy takes nothing returns integer
	return GetLearnedSkill()
endfunction

function jy takes boolean ly, unit ky returns nothing
	call (ky, not ly)
endfunction

function my takes player oy, real ny returns nothing
	call (oy, ny * 0.01)
endfunction

function py takes player qy returns real
	return GetPlayerHandicapXP(qy) * 100
endfunction

function ry takes player ty, real sy returns nothing
	call (ty, sy * 0.01)
endfunction

function uy takes player vy returns real
	return GetPlayerHandicap(vy) * 100
endfunction

function wy takes integer zy, unit yy, boolean xy returns integer
	if (zy == Ye) then
		return GetHeroStr(yy, xy)
	elseif (zy == Ye) then
		return GetHeroAgi(yy, xy)
	elseif (zy == Ye) then
		return GetHeroInt(yy, xy)
	else
		return 0
	endif
endfunction

function Ay takes unit Dy, integer Cy, integer By returns nothing
	if (By <= 0) then
		return
	endif
	if (Cy == Ye) then
		call (Dy, By, true)
	elseif (Cy == Ye) then
		call (Dy, By, true)
	elseif (Cy == Ye) then
		call (Dy, By, true)
	else
	endif
endfunction

function Ey takes integer Iy, unit Hy, integer Gy, integer Fy returns nothing
	if (Gy == bf) then
		call Ay(Hy, Iy, wy(Iy, Hy, false) + Fy)
	elseif (Gy == bf) then
		call Ay(Hy, Iy, wy(Iy, Hy, false) - Fy)
	elseif (Gy == bf) then
		call Ay(Hy, Iy, Fy)
	else
	endif
endfunction

function Jy takes unit My, integer Ly, integer Ky returns boolean
	if (Ly == bf) then
		return UnitModifySkillPoints(My, Ky)
	elseif (Ly == bf) then
		return UnitModifySkillPoints(My, -Ky)
	elseif (Ly == bf) then
		return UnitModifySkillPoints(My, Ky - GetHeroSkillPoints(My))
	else
		return false
	endif
endfunction

function Ny takes unit Ry, item Qy, real Py, real Oy returns boolean
	return UnitDropItemPoint(Ry, Qy, Py, Oy)
endfunction

function Sy takes unit Vy, item Uy, location Ty returns boolean
	return UnitDropItemPoint(Vy, Uy, GetLocationX(Ty), GetLocationY(Ty))
endfunction

function Wy takes unit Zy, item Yy, integer Xy returns boolean
	return UnitDropItemSlot(Zy, Yy, Xy - 1)
endfunction

function az takes unit dz, item cz, widget bz returns boolean
	return UnitDropItemTarget(dz, cz, bz)
endfunction

function ez takes unit hz, item gz, widget fz returns boolean
	return UnitUseItemTarget(hz, gz, fz)
endfunction

function iz takes unit lz, item kz, location jz returns boolean
	return UnitUseItemPoint(lz, kz, GetLocationX(jz), GetLocationY(jz))
endfunction

function mz takes unit oz, integer nz returns item
	return UnitItemInSlot(oz, nz - 1)
endfunction

function pz takes unit tz, integer sz returns integer
	local integer rz
	local item qz
	set rz = 0
	loop
		set qz = UnitItemInSlot(tz, rz)
		if (qz != null) and (GetItemTypeId(qz) == sz) then
			return rz + 1
		endif
		set rz = rz + 1
		exitwhen rz >= C
	endloop
	return 0
endfunction

function uz takes unit xz, integer wz returns item
	local integer vz = pz(xz, wz)
	if (vz == 0) then
		return null
	else
		return UnitItemInSlot(xz, vz - 1)
	endif
endfunction

function yz takes unit Az, integer zz returns boolean
	return pz(Az, zz) > 0
endfunction

function Bz takes unit Ez returns integer
	local integer Dz = 0
	local integer Cz = 0
	loop
		if (UnitItemInSlot(Ez, Dz) != null) then
			set Cz = Cz + 1
		endif
		set Dz = Dz + 1
		exitwhen Dz >= C
	endloop
	return Cz
endfunction

function Fz takes unit Gz returns integer
	return UnitInventorySize(Gz)
endfunction

function Hz takes item Jz, boolean Iz returns nothing
	call (Jz, Iz)
endfunction

function Kz takes item Mz, boolean Lz returns nothing
	call (Mz, Lz)
endfunction

function Nz takes item Pz, boolean Oz returns nothing
	call (Pz, Oz)
endfunction

function Qz takes item Tz, player Sz, boolean Rz returns nothing
	call (Tz, Sz, Rz)
endfunction

function Uz takes boolean Wz, item Vz returns nothing
	call (Vz, Wz)
endfunction

function Xz takes item Yz returns boolean
	return not IsItemVisible(Yz)
endfunction

function Zz takes integer aA returns integer
	return ChooseRandomItem(aA)
endfunction

function bA takes integer dA, itemtype cA returns integer
	return ChooseRandomItemEx(cA, dA)
endfunction

function eA takes nothing returns integer
	return ChooseRandomNPBuilding()
endfunction

function fA takes integer gA returns integer
	return ChooseRandomCreep(gA)
endfunction

function hA takes rect jA, code iA returns nothing
	call (jA, null, iA)
endfunction

function kA takes nothing returns nothing
	set Uh = Uh + 1
	if (GetRandomInt(1, Uh) == 1) then
		set Vh = GetEnumItem()
	endif
endfunction

function lA takes rect nA, boolexpr mA returns item
	set Uh = 0
	set Vh = null
	call (nA, mA, function )
	call (mA)
	return Vh
endfunction

function oA takes rect pA returns item
	return lA(pA, null)
endfunction

function qA takes item sA, integer rA returns boolean
	if (rA == wf) then
		return not IsItemVisible(sA)
	elseif (rA == wf) then
		return IsItemOwned(sA)
	elseif (rA == wf) then
		return IsItemInvulnerable(sA)
	elseif (rA == wf) then
		return IsItemPowerup(sA)
	elseif (rA == wf) then
		return IsItemSellable(sA)
	elseif (rA == wf) then
		return IsItemPawnable(sA)
	else
		return false
	endif
endfunction

function tA takes integer vA, integer uA returns boolean
	if (uA == Cf) then
		return IsItemIdPowerup(vA)
	elseif (uA == Cf) then
		return IsItemIdSellable(vA)
	elseif (uA == Cf) then
		return IsItemIdPawnable(vA)
	else
		return false
	endif
endfunction

function wA takes integer xA returns integer
	return xA
endfunction

function yA takes string zA returns integer
	return UnitId(zA)
endfunction

function AA takes integer CA returns string
	local string BA = UnitId2String(CA)
	if (BA != null) then
		return BA
	endif
	return ""
endfunction

function DA takes string FA returns integer
	local integer EA
	set EA = OrderId(FA)
	if (EA != 0) then
		return EA
	endif
	set EA = UnitId(FA)
	if (EA != 0) then
		return EA
	endif
	return 0
endfunction

function GA takes integer IA returns string
	local string HA
	set HA = OrderId2String(IA)
	if (HA != null) then
		return HA
	endif
	set HA = UnitId2String(IA)
	if (HA != null) then
		return HA
	endif
	return ""
endfunction

function JA takes nothing returns integer
	return GetIssuedOrderId()
endfunction

function KA takes nothing returns unit
	return GetKillingUnit()
endfunction

function LA takes player PA, integer OA, location NA, real MA returns unit
	if (OA == 'ugol') then
		set ti = CreateBlightedGoldmine(PA, GetLocationX(NA), GetLocationY(NA), MA)
	else
		set ti = CreateUnitAtLoc(PA, OA, NA, MA)
	endif
	return ti
endfunction

function QA takes nothing returns unit
	return ti
endfunction

function RA takes integer WA, integer VA, player UA, location TA, real SA returns group
	call (yi)
	loop
		set WA = WA - 1
		exitwhen WA < 0
		call LA(UA, VA, TA, SA)
		call (yi, ti)
	endloop
	return yi
endfunction

function XA takes integer cB, integer bB, player aB, location ZA, location YA returns group
	return RA(cB, bB, aB, ZA, Qj(ZA, YA))
endfunction

function dB takes nothing returns nothing
	call (Lh, GetEnumUnit())
endfunction

function eB takes nothing returns group
	set Lh = CreateGroup()
	call (yi, function )
	return Lh
endfunction

function fB takes integer iB, player hB, location gB returns unit
	set ti = CreateCorpse(hB, iB, GetLocationX(gB), GetLocationY(gB), GetRandomReal(0, 360))
	return ti
endfunction

function jB takes boolean lB, unit kB returns nothing
	call (kB, lB)
endfunction

function mB takes nothing returns nothing
	local unit nB = GetEnumUnit()
	if (GetUnitState(nB, ) <= 0) then
		call (nB, 0.0001)
	endif
endfunction

function oB takes nothing returns nothing
	local unit pB = GetEnumUnit()
	if (GetUnitState(pB, ) <= 0) then
		call (pB, true)
		call (pB, 0.0001)
	endif
endfunction

function qB takes nothing returns nothing
	local unit rB = GetEnumUnit()
	if (GetUnitState(rB, ) <= 0) then
		call (rB, true)
		call (rB, 10.0)
		call (rB, "decay flesh")
	endif
endfunction

function sB takes nothing returns nothing
	local group uB
	local group tB
	set uB = li
	set tB = ki
	set li = CreateGroup()
	set ki = CreateGroup()
	call (tB, function )
	call (uB, function )
	call (If)
	call (tB, function )
	call (uB, function )
	call (0.05)
	call (tB, function )
	call (uB)
	call (tB)
endfunction

function vB takes nothing returns nothing
	set ni = CreateTrigger()
	call (ni, mi)
	call (ni, function )
endfunction

function wB takes integer BB, integer AB, player zB, location yB, real xB returns unit
	set ti = CreateCorpse(zB, AB, GetLocationX(yB), GetLocationY(yB), xB)
	call (ti, 0)
	if (BB == Jf) then
		call (ti, "decay flesh")
		call (ki, ti)
	elseif (BB == Jf) then
		call (ti, "decay bone")
		call (li, ti)
	else
		call (ti, "decay bone")
		call (li, ti)
	endif
	call (mi, 0.05, false, null)
	return ti
endfunction

function CB takes unitstate EB, unit DB returns real
	return GetUnitState(DB, EB)
endfunction

function FB takes unit KB, unitstate JB, unitstate IB returns real
	local real HB = GetUnitState(KB, JB)
	local real GB = GetUnitState(KB, IB)
	if (KB == null) or (GB == 0) then
		return 0.0
	endif
	return HB / GB * 100.0
endfunction

function LB takes unit MB returns real
	return FB(MB, , )
endfunction

function NB takes unit OB returns real
	return FB(OB, , )
endfunction

function PB takes unit QB returns nothing
	call ()
	call (QB, true)
endfunction

function RB takes nothing returns nothing
	call (GetEnumUnit(), true)
endfunction

function SB takes group TB returns nothing
	call ()
	call (TB, function )
endfunction

function UB takes unit VB returns nothing
	call (VB, true)
endfunction

function WB takes unit XB returns nothing
	call (XB, false)
endfunction

function YB takes player ZB returns nothing
	if (GetLocalPlayer() == ZB) then
		call ()
	endif
endfunction

function aC takes unit cC, player bC returns nothing
	if (GetLocalPlayer() == bC) then
		call ()
		call (cC, true)
	endif
endfunction

function dC takes group fC, player eC returns nothing
	if (GetLocalPlayer() == eC) then
		call ()
		call (fC, function )
	endif
endfunction

function gC takes unit iC, player hC returns nothing
	if (GetLocalPlayer() == hC) then
		call (iC, true)
	endif
endfunction

function jC takes unit lC, player kC returns nothing
	if (GetLocalPlayer() == kC) then
		call (lC, false)
	endif
endfunction

function mC takes unit oC, real nC returns nothing
	call (oC, , kj(0, nC))
endfunction

function pC takes unit rC, real qC returns nothing
	call (rC, , kj(0, qC))
endfunction

function sC takes unit uC, real tC returns nothing
	call (uC, , GetUnitState(uC, ) * kj(0, tC) * 0.01)
endfunction

function vC takes unit xC, real wC returns nothing
	call (xC, , GetUnitState(xC, ) * kj(0, wC) * 0.01)
endfunction

function yC takes unit zC returns boolean
	return GetUnitState(zC, ) <= 0
endfunction

function AC takes unit BC returns boolean
	return not yC(BC)
endfunction

function CC takes nothing returns nothing
	if not yC(GetEnumUnit()) then
		set ei = false
	endif
endfunction

function DC takes group FC returns boolean
	local boolean EC = dj
	set dj = false
	set ei = true
	call (FC, function )
	if (EC) then
		call (FC)
	endif
	return ei
endfunction

function GC takes nothing returns nothing
	set fi = false
endfunction

function HC takes group JC returns boolean
	local boolean IC = dj
	set dj = false
	set fi = true
	call (JC, function )
	if (IC) then
		call (JC)
	endif
	return fi
endfunction

function KC takes nothing returns nothing
	if not Lk(hi, GetEnumUnit()) then
		set gi = false
	endif
endfunction

function LC takes group NC, rect MC returns boolean
	set gi = true
	set hi = MC
	call (NC, function )
	return gi
endfunction

function OC takes unit PC returns boolean
	return IsUnitHidden(PC)
endfunction

function QC takes unit RC returns nothing
	call (RC, false)
endfunction

function SC takes unit TC returns nothing
	if (IsUnitType(TC, ) and yC(TC)) then
		return
	endif
	call (TC, true)
endfunction

function UC takes nothing returns boolean
	return GetUnitTypeId(GetFilterUnit()) == 'ngol'
endfunction

function VC takes unit ZC, location YC returns boolean
	local group XC = null
	local unit WC = null
	set XC = CreateGroup()
	call (XC, YC, 2 * c, Wi)
	set WC = FirstOfGroup(XC)
	call (XC)
	if (WC == null) then
		return false
	endif
	return IssueTargetOrderById(ZC, 'ugol', WC)
endfunction

function aD takes unit dD, integer cD, location bD returns boolean
	if (cD == 'ugol') then
		return VC(dD, bD)
	else
		return IssueBuildOrderById(dD, cD, GetLocationX(bD), GetLocationY(bD))
	endif
endfunction

function eD takes unit gD, integer fD returns boolean
	return IssueImmediateOrderById(gD, fD)
endfunction

function hD takes group jD, integer iD returns boolean
	return GroupImmediateOrderById(jD, iD)
endfunction

function kD takes unit mD, integer lD returns boolean
	return IssueImmediateOrderById(mD, lD)
endfunction

function nD takes nothing returns unit
	return GetTriggerUnit()
endfunction

function oD takes unit rD, real qD, real pD returns nothing
	call (rD, qD, pD)
endfunction

function sD takes unit uD, real tD returns nothing
	call (uD, tD)
endfunction

function vD takes unit yD, real xD returns nothing
	local real wD = xD
	if (wD <= 0) then
		set wD = 1
	elseif (wD <= 0) then
		set wD = 359
	endif
	set wD = wD * g
	call (yD, wD)
endfunction

function zD takes unit AD returns real
	return GetUnitPropWindow(AD) * f
endfunction

function BD takes unit CD returns real
	return GetUnitDefaultPropWindow(CD)
endfunction

function DD takes unit FD, real ED returns nothing
	call (FD, ED)
endfunction

function GD takes unit ID, real HD returns nothing
	call (ID, HD)
endfunction

function JD takes unit LD, boolean KD returns nothing
	call (LD, KD)
endfunction

function MD takes unit ND returns boolean
	return UnitCanSleep(ND)
endfunction

function OD takes unit PD returns nothing
	call (PD)
endfunction

function QD takes unit RD returns boolean
	return UnitIsSleeping(RD)
endfunction

function SD takes nothing returns nothing
	call (GetEnumUnit())
endfunction

function TD takes player VD returns nothing
	local group UD = CreateGroup()
	call (UD, VD, null)
	call (UD, function )
	call (UD)
endfunction

function WD takes boolean XD returns nothing
	call (Player(), , Jl(XD, 0, 1))
	if (not XD) then
		call TD(Player())
	endif
endfunction

function YD takes unit aE, boolean ZD returns boolean
	return UnitIgnoreAlarm(aE, not ZD)
endfunction

function bE takes unit cE returns boolean
	return not UnitIgnoreAlarmToggled(cE)
endfunction

function dE takes nothing returns nothing
	call (GetEnumUnit(), ai)
endfunction

function eE takes boolean iE returns nothing
	local integer hE
	local player gE
	local group fE
	set ai = iE
	set fE = CreateGroup()
	set hE = 0
	loop
		set gE = Player(hE)
		if (GetPlayerController(gE) == ) then
			call (gE, iE)
		endif
		call (fE, gE, null)
		call (fE, function )
		call (fE)
		set hE = hE + 1
		exitwhen hE == G
	endloop
	call (fE)
endfunction

function jE takes boolean lE, unit kE returns nothing
	call (kE, lE)
endfunction

function mE takes unit nE returns boolean
	return IsUnitPaused(nE)
endfunction

function oE takes boolean qE, unit pE returns nothing
	call (pE, qE)
endfunction

function rE takes real uE, integer tE, unit sE returns nothing
	call (sE, tE, uE)
endfunction

function vE takes boolean yE, unit xE, player wE returns nothing
	call (xE, wE, yE)
endfunction

function zE takes integer BE, unit AE returns nothing
	if (BE == Ne) then
		call (AE, true, false)
	elseif (BE == Ne) then
		call (AE, false, true)
	elseif (BE == Ne) then
		call (AE, true, true)
	elseif (BE == Ne) then
		call (AE, true, true, false, false, false, true, false)
	else
	endif
endfunction

function CE takes integer LE, integer KE, unit JE, boolean IE, boolean HE returns nothing
	local boolean GE = (LE == Te) or (LE == Re)
	local boolean FE = (LE == Te) or (LE == Se)
	local boolean EE = (KE == Xe) or (KE == Ue)
	local boolean DE = (KE == Xe) or (KE == Ve)
	call (JE, GE, FE, EE, DE, IE, HE, false)
endfunction

function ME takes integer VE, integer UE, unit TE, boolean SE, boolean RE returns integer
	local boolean QE = (VE == Te) or (VE == Re)
	local boolean PE = (VE == Te) or (VE == Se)
	local boolean OE = (UE == Xe) or (UE == Ue)
	local boolean NE = (UE == Xe) or (UE == Ve)
	return UnitCountBuffsEx(TE, QE, PE, OE, NE, SE, RE, false)
endfunction

function WE takes integer YE, unit XE returns boolean
	return UnitRemoveAbility(XE, YE)
endfunction

function ZE takes integer bF, unit aF returns boolean
	return UnitAddAbility(aF, bF)
endfunction

function cF takes unittype eF, unit dF returns boolean
	return UnitRemoveType(dF, eF)
endfunction

function fF takes unittype hF, unit gF returns boolean
	return UnitAddType(gF, hF)
endfunction

function iF takes boolean lF, integer kF, unit jF returns boolean
	return UnitMakeAbilityPermanent(jF, lF, kF)
endfunction

function mF takes unit oF, boolean nF returns nothing
	call (oF, nF)
endfunction

function pF takes unit qF returns nothing
	call (qF, true)
	call (qF)
endfunction

function rF takes nothing returns unit
	return GetTransportUnit()
endfunction

function sF takes nothing returns unit
	return GetLoadedUnit()
endfunction

function tF takes unit vF, unit uF returns boolean
	return IsUnitInTransport(vF, uF)
endfunction

function wF takes unit xF returns boolean
	return IsUnitLoaded(xF)
endfunction

function yF takes unit zF returns boolean
	return IsUnitIllusion(zF)
endfunction

function AF takes unit JF, integer IF, integer HF returns unit
	local unit GF = JF
	local unit FF
	local boolean EF
	local integer DF
	local item CF
	local real BF
	if (GF == null) then
		set Ri = GF
		return GF
	endif
	set EF = IsUnitHidden(GF)
	call (GF, false)
	if (IF == 'ugol') then
		set FF = CreateBlightedGoldmine(GetOwningPlayer(GF), GetUnitX(GF), GetUnitY(GF), GetUnitFacing(GF))
	else
		set FF = CreateUnit(GetOwningPlayer(GF), IF, GetUnitX(GF), GetUnitY(GF), GetUnitFacing(GF))
	endif
	if (HF == ff) then
		if (GetUnitState(GF, ) > 0) then
			set BF = GetUnitState(GF, ) / GetUnitState(GF, )
			call (FF, , BF * GetUnitState(FF, ))
		endif
		if (GetUnitState(GF, ) > 0) and (GetUnitState(FF, ) > 0) then
			set BF = GetUnitState(GF, ) / GetUnitState(GF, )
			call (FF, , BF * GetUnitState(FF, ))
		endif
	elseif (HF == ff) then
		call (FF, , GetUnitState(GF, ))
		if (GetUnitState(FF, ) > 0) then
			call (FF, , GetUnitState(GF, ))
		endif
	elseif (HF == ff) then
	elseif (HF == ff) then
		call (FF, , GetUnitState(FF, ))
		call (FF, , GetUnitState(FF, ))
	else
	endif
	call (FF, GetResourceAmount(GF))
	if (IsUnitType(GF, ) and IsUnitType(FF, )) then
		call (FF, GetHeroXP(GF), false)
		set DF = 0
		loop
			set CF = UnitItemInSlot(GF, DF)
			if (CF != null) then
				call (GF, CF)
				call (FF, CF)
			endif
			set DF = DF + 1
			exitwhen DF >= C
		endloop
	endif
	if EF then
		call (GF)
		call (GF)
	else
		call (GF)
	endif
	set Ri = FF
	return FF
endfunction

function KF takes nothing returns unit
	return Ri
endfunction

function LF takes unit OF, location NF, real MF returns nothing
	call (OF, NF)
	call (OF, MF)
endfunction

function PF takes unit SF, location RF, location QF returns nothing
	call (SF, RF)
	call (SF, Qj(RF, QF))
endfunction

function TF takes integer XF, unit WF, integer VF, integer UF returns nothing
	call (WF, XF, VF, UF)
endfunction

function YF takes integer cG, unit bG, integer aG, integer ZF returns nothing
	call (bG, cG, aG, ZF)
endfunction

function dG takes integer fG, unit eG returns nothing
	call (eG, fG)
endfunction

function gG takes integer iG, unit hG returns nothing
	call (hG, iG)
endfunction

function jG takes boolean lG, unit kG returns nothing
	call (kG, lG)
endfunction

function mG takes unit tG, real sG, real rG, location qG, real pG, attacktype oG, damagetype nG returns boolean
	return UnitDamagePoint(tG, sG, rG, GetLocationX(qG), GetLocationY(qG), pG, true, false, oG, nG, )
endfunction

function uG takes unit zG, unit yG, real xG, attacktype wG, damagetype vG returns boolean
	return UnitDamageTarget(zG, yG, xG, true, false, wG, vG, )
endfunction

function AG takes integer FG, location EG, real DG, real CG, integer BG returns destructable
	set xi = CreateDestructable(FG, GetLocationX(EG), GetLocationY(EG), DG, CG, BG)
	return xi
endfunction

function GG takes integer LG, location KG, real JG, real IG, integer HG returns destructable
	set xi = CreateDeadDestructable(LG, GetLocationX(KG), GetLocationY(KG), JG, IG, HG)
	return xi
endfunction

function MG takes nothing returns destructable
	return xi
endfunction

function NG takes boolean PG, destructable OG returns nothing
	call (OG, PG)
endfunction

function QG takes destructable SG, boolean RG returns nothing
	call (SG, RG)
endfunction

function TG takes destructable UG returns boolean
	return IsDestructableInvulnerable(UG)
endfunction

function VG takes destructable WG returns location
	return Location(GetDestructableX(WG), GetDestructableY(WG))
endfunction

function XG takes rect ZG, code YG returns nothing
	call (ZG, null, YG)
endfunction

function aH takes nothing returns boolean
	local location cH = VG(GetFilterDestructable())
	local boolean bH
	set bH = Tj(cH, bi) <= ci
	call (cH)
	return bH
endfunction

function dH takes destructable eH returns boolean
	return GetDestructableLife(eH) <= 0
endfunction

function fH takes destructable gH returns boolean
	return not dH(gH)
endfunction

function hH takes nothing returns nothing
	set Qh = Qh + 1
	if (GetRandomInt(1, Qh) == 1) then
		set Rh = GetEnumDestructable()
	endif
endfunction

function iH takes rect kH, boolexpr jH returns destructable
	set Qh = 0
	set Rh = null
	call (kH, jH, function )
	call (jH)
	return Rh
endfunction

function lH takes rect mH returns destructable
	return iH(mH, null)
endfunction

function nH takes real rH, location qH, code pH returns nothing
	local rect oH
	if (rH >= 0) then
		set bi = qH
		set ci = rH
		set oH = tm(qH, rH)
		call (oH, Xi, pH)
		call (oH)
	endif
endfunction

function sH takes destructable uH, real tH returns nothing
	call (uH, GetDestructableMaxLife(uH) * tH * 0.01)
endfunction

function vH takes destructable xH, real wH returns nothing
	call (xH, wH)
endfunction

function yH takes integer AH, destructable zH returns nothing
	if (AH == jf) then
		if (GetDestructableLife(zH) <= 0) then
			call (zH, GetDestructableMaxLife(zH), true)
		endif
		call (zH, "stand")
	elseif (AH == jf) then
		if (GetDestructableLife(zH) > 0) then
			call (zH)
		endif
		call (zH, "death alternate")
	elseif (AH == jf) then
		if (GetDestructableLife(zH) > 0) then
			call (zH)
		endif
		call (zH, "death")
	else
	endif
endfunction

function BH takes destructable DH returns integer
	local integer CH
	set CH = 1 + R2I(GetDestructableOccluderHeight(DH) / d)
	if (CH < 1) or (CH > 3) then
		set CH = 1
	endif
	return CH
endfunction

function EH takes destructable HH, integer GH returns nothing
	local integer FH
	set GH = uj(1, GH)
	set GH = rj(3, GH)
	set FH = BH(HH)
	call (HH, d * (GH - 1))
	if (GH == 1) then
		if (FH == 2) then
			call (HH, "birth")
			call (HH, "stand")
		elseif (FH == 2) then
			call (HH, "birth third")
			call (HH, "stand")
		else
			call (HH, "stand")
		endif
	elseif (GH == 1) then
		if (FH == 1) then
			call (HH, "death")
			call (HH, "stand second")
		elseif (FH == 1) then
			call (HH, "birth second")
			call (HH, "stand second")
		else
			call (HH, "stand second")
		endif
	elseif (GH == 1) then
		if (FH == 1) then
			call (HH, "death third")
			call (HH, "stand third")
		elseif (FH == 1) then
			call (HH, "death second")
			call (HH, "stand third")
		else
			call (HH, "stand third")
		endif
	else
	endif
endfunction

function IH takes nothing returns nothing
	local unit JH = GetEnumUnit()
	call (JH, GetUnitX(JH), GetUnitY(JH))
endfunction

function KH takes nothing returns nothing
	local item LH = GetEnumItem()
	call (LH, GetItemX(LH), GetItemY(LH))
endfunction

function MH takes rect OH returns nothing
	local group NH
	set NH = CreateGroup()
	call (NH, OH, null)
	call (NH, function )
	call (NH)
	call (OH, null, function )
endfunction

function PH takes nothing returns nothing
	local destructable RH = GetEnumDestructable()
	local integer QH = GetDestructableTypeId(RH)
	if (QH == Mf) or (QH == Nf) then
		set Th = RH
	endif
endfunction

function SH takes real WH, real VH returns boolean
	local real UH = 32
	local rect TH
	set TH = Rect(WH - UH, VH - UH, WH + UH, VH + UH)
	set Th = null
	call (TH, null, function )
	call (TH)
	return Th != null
endfunction

function XH takes nothing returns nothing
	set Sh = GetEnumDestructable()
endfunction

function YH takes real hI, real gI, real fI, boolean eI returns nothing
	local destructable dI = null
	local real cI = 32
	local real bI = 4.25 * c
	local real aI = 1.25 * c
	local rect ZH
	set ZH = Rect(hI - cI, gI - cI, hI + cI, gI + cI)
	set Sh = null
	call (ZH, null, function )
	call (ZH)
	set dI = Sh
	if (dI == null) then
		set dI = CreateDeadDestructable(Lf, hI, gI, fI, 1, 0)
	elseif (dI == null) then
		return
	endif
	if (eI) then
		if (GetDestructableLife(dI) > 0) then
			call (dI)
		endif
	else
		if (GetDestructableLife(dI) <= 0) then
			call (dI, GetDestructableMaxLife(dI), false)
		endif
		if (fI == 0) then
			set ZH = Rect(hI - aI / 2, gI - bI / 2, hI + aI / 2, gI + bI / 2)
			call MH(ZH)
			call (ZH)
		elseif (fI == 0) then
			set ZH = Rect(hI - bI / 2, gI - aI / 2, hI + bI / 2, gI + aI / 2)
			call MH(ZH)
			call (ZH)
		else
		endif
	endif
endfunction

function iI takes boolean pI, integer oI, destructable nI returns nothing
	local real mI = GetDestructableX(nI)
	local real lI = GetDestructableY(nI)
	local real kI = 192
	local real jI = 256
	if (oI == Of) or (oI == Pf) then
		if (not SH(mI + jI, lI)) then
			call YH(mI + kI, lI, 0, pI)
		endif
	endif
	if (oI == Of) or (oI == Qf) then
		if (not SH(mI, lI + jI)) then
			call YH(mI, lI + kI, 90, pI)
		endif
	endif
	if (oI == Of) or (oI == Rf) then
		if (not SH(mI, lI - jI)) then
			call YH(mI, lI - kI, 90, pI)
		endif
	endif
	if (oI == Of) or (oI == Sf) then
		if (not SH(mI - jI, lI)) then
			call YH(mI - kI, lI, 0, pI)
		endif
	endif
endfunction

function qI takes boolean sI, unit rI returns nothing
	call (rI, sI)
endfunction

function tI takes unit uI returns boolean
	return WaygateIsActive(uI)
endfunction

function vI takes unit xI, location wI returns nothing
	call (xI, GetLocationX(wI), GetLocationY(wI))
endfunction

function yI takes unit zI returns location
	return Location(WaygateGetDestinationX(zI), WaygateGetDestinationY(zI))
endfunction

function AI takes boolean CI, unit BI returns nothing
	call (BI, CI)
endfunction

function DI takes player FI, string EI returns nothing
	if (GetLocalPlayer() == FI) then
		call (EI)
	endif
endfunction

function GI takes player HI returns nothing
	if (GetLocalPlayer() == HI) then
		call ()
	endif
endfunction

function II takes group LI, code KI returns nothing
	local boolean JI = dj
	set dj = false
	call (LI, KI)
	if (JI) then
		call (LI)
	endif
endfunction

function MI takes unit OI, group NI returns nothing
	call (NI, OI)
endfunction

function PI takes unit RI, group QI returns nothing
	call (QI, RI)
endfunction

function SI takes nothing returns nothing
	call (Hh, GetEnumUnit())
endfunction

function TI takes group WI, group VI returns nothing
	local boolean UI = dj
	set dj = false
	set Hh = VI
	call (WI, function )
	if (UI) then
		call (WI)
	endif
endfunction

function XI takes nothing returns nothing
	call (Ih, GetEnumUnit())
endfunction

function YI takes group bJ, group aJ returns nothing
	local boolean ZI = dj
	set dj = false
	set Ih = aJ
	call (bJ, function )
	if (ZI) then
		call (bJ)
	endif
endfunction

function cJ takes player eJ, force dJ returns nothing
	call (dJ, eJ)
endfunction

function fJ takes player hJ, force gJ returns nothing
	call (gJ, hJ)
endfunction

function iJ takes nothing returns nothing
	set Jh = Jh + 1
	if (GetRandomInt(1, Jh) == 1) then
		set Kh = GetEnumUnit()
	endif
endfunction

function jJ takes group lJ returns unit
	local boolean kJ = dj
	set dj = false
	set Jh = 0
	set Kh = null
	call (lJ, function )
	if (kJ) then
		call (lJ)
	endif
	return Kh
endfunction

function mJ takes nothing returns nothing
	set Wh = Wh + 1
	if (GetRandomInt(1, Wh) == 1) then
		set Xh = GetEnumPlayer()
	endif
endfunction

function nJ takes force oJ returns player
	set Wh = 0
	set Xh = null
	call (oJ, function )
	return Xh
endfunction

function pJ takes player tJ, boolexpr sJ, code rJ returns nothing
	local group qJ = CreateGroup()
	call ()
	call (qJ, tJ, sJ)
	call (sJ)
	call (qJ, rJ)
	call (qJ)
endfunction

function uJ takes rect xJ, boolexpr wJ returns group
	local group vJ = CreateGroup()
	call (vJ, xJ, wJ)
	call (wJ)
	return vJ
endfunction

function yJ takes rect zJ returns group
	return uJ(zJ, null)
endfunction

function AJ takes nothing returns boolean
	return GetOwningPlayer(GetFilterUnit()) == Gh
endfunction

function BJ takes rect EJ, player DJ returns group
	local group CJ = CreateGroup()
	set Gh = DJ
	call (CJ, EJ, Yi)
	return CJ
endfunction

function FJ takes real JJ, location IJ, boolexpr HJ returns group
	local group GJ = CreateGroup()
	call (GJ, IJ, JJ, HJ)
	call (HJ)
	return GJ
endfunction

function KJ takes real MJ, location LJ returns group
	return FJ(MJ, LJ, null)
endfunction

function NJ takes nothing returns boolean
	return GetUnitTypeId(GetFilterUnit()) == Fh
endfunction

function OJ takes integer SJ returns group
	local group RJ = CreateGroup()
	local group QJ = CreateGroup()
	local integer PJ
	set PJ = 0
	loop
		set Fh = SJ
		call (QJ)
		call (QJ, Player(PJ), Zi)
		call TI(QJ, RJ)
		set PJ = PJ + 1
		exitwhen PJ == G
	endloop
	call (QJ)
	return RJ
endfunction

function TJ takes player WJ, boolexpr VJ returns group
	local group UJ = CreateGroup()
	call (UJ, WJ, VJ)
	call (VJ)
	return UJ
endfunction

function XJ takes player YJ returns group
	return TJ(YJ, null)
endfunction

function ZJ takes nothing returns boolean
	return GetUnitTypeId(GetFilterUnit()) == Fh
endfunction

function aK takes player dK, integer cK returns group
	local group bK = CreateGroup()
	set Fh = cK
	call (bK, dK, aj)
	return bK
endfunction

function eK takes player gK returns group
	local group fK = CreateGroup()
	call ()
	call (fK, gK, null)
	return fK
endfunction

function hK takes player jK returns force
	local force iK = CreateForce()
	call (iK, jK)
	return iK
endfunction

function kK takes nothing returns force
	return Tf
endfunction

function lK takes mapcontrol pK returns force
	local force oK = CreateForce()
	local integer nK
	local player mK
	set nK = 0
	loop
		set mK = Player(nK)
		if GetPlayerController(mK) == pK then
			call (oK, mK)
		endif
		set nK = nK + 1
		exitwhen nK == G
	endloop
	return oK
endfunction

function qK takes player sK returns force
	local force rK = CreateForce()
	call (rK, sK, null)
	return rK
endfunction

function tK takes player vK returns force
	local force uK = CreateForce()
	call (uK, vK, null)
	return uK
endfunction

function wK takes boolexpr yK returns force
	local force xK = CreateForce()
	call (xK, yK)
	call (yK)
	return xK
endfunction

function zK takes nothing returns nothing
	set Dh = Dh + 1
endfunction

function AK takes group CK returns integer
	local boolean BK = dj
	set dj = false
	set Dh = 0
	call (CK, function )
	if (BK) then
		call (CK)
	endif
	return Dh
endfunction

function DK takes nothing returns nothing
	set Eh = Eh + 1
endfunction

function EK takes force FK returns integer
	set Eh = 0
	call (FK, function )
	return Eh
endfunction

function GK takes nothing returns nothing
	if (Nh > 0) then
		if (Nh >= Oh) or (GetRandomReal(0, 1) < Ph) then
			call (Mh, GetEnumUnit())
			set Nh = Nh - 1
		endif
	endif
	set Oh = Oh - 1
endfunction

function HK takes integer KK, group JK returns group
	local group IK = CreateGroup()
	set Mh = IK
	set Nh = KK
	set Oh = AK(JK)
	if (Nh <= 0 or Oh <= 0) then
		return IK
	endif
	set Ph = I2R(Nh) / I2R(Oh)
	call (JK, function )
	return IK
endfunction

function LK takes nothing returns boolean
	local unit MK = GetFilterUnit()
	return AC(MK) and GetUnitTypeId(MK) == oi
endfunction

function NK takes integer RK, player QK returns integer
	local group PK
	local integer OK
	set PK = CreateGroup()
	set oi = RK
	call (PK, QK, cj)
	set OK = AK(PK)
	call (PK)
	return OK
endfunction

function SK takes unit TK returns nothing
	call (TK, "stand")
endfunction

function UK takes unit WK, real VK returns nothing
	call (WK, VK * 0.01)
endfunction

function XK takes unit bL, real aL, real ZK, real YK returns nothing
	call (bL, aL * 0.01, ZK * 0.01, YK * 0.01)
endfunction

function cL takes unit hL, real gL, real fL, real eL, real dL returns nothing
	call (hL, cm(gL), cm(fL), cm(eL), cm(100.0 - dL))
endfunction

function iL takes unit nL, real mL, real lL, real kL, real jL returns nothing
	call (nL, cm(mL), cm(lL), cm(kL), cm(100.0 - jL))
endfunction

function oL takes destructable tL, real sL, real rL, real qL, real pL returns nothing
	call (tL, cm(sL), cm(rL), cm(qL), cm(100.0 - pL))
endfunction

function uL takes item zL, real yL, real xL, real wL, real vL returns nothing
	call (zL, cm(yL), cm(xL), cm(wL), cm(100.0 - vL))
endfunction

function AL takes unit EL, location DL, real CL returns nothing
	local location BL = GetUnitLoc(EL)
	call (EL, Qj(BL, DL), CL)
	call (BL)
endfunction

function FL takes unit JL, unit IL, real HL returns nothing
	local location GL = GetUnitLoc(IL)
	call AL(JL, GL, HL)
	call (GL)
endfunction

function KL takes unit ML, string LL returns nothing
	call (ML, LL)
endfunction

function NL takes destructable PL, string OL returns nothing
	call (PL, OL)
endfunction

function QL takes destructable SL, string RL returns nothing
	call (SL, RL)
endfunction

function TL takes destructable VL, real UL returns nothing
	call (VL, UL * 0.01)
endfunction

function WL takes boolean ZL, dialog YL, player XL returns nothing
	call (XL, YL, ZL)
endfunction

function aM takes dialog cM, string bM returns nothing
	call (cM, bM)
endfunction

function dM takes dialog fM, string eM returns button
	set Qi = DialogAddButton(fM, eM, 0)
	return Qi
endfunction

function gM takes dialog jM, string iM, integer hM returns button
	set Qi = DialogAddButton(jM, iM, hM)
	return Qi
endfunction

function kM takes dialog lM returns nothing
	call (lM)
endfunction

function mM takes nothing returns button
	return Qi
endfunction

function nM takes nothing returns button
	return GetClickedButton()
endfunction

function oM takes nothing returns dialog
	return GetClickedDialog()
endfunction

function pM takes player tM, alliancetype sM, boolean rM, player qM returns nothing
	if (tM == qM) then
		return
	endif
	call (tM, qM, sM, rM)
endfunction

function uM takes player xM, player wM, boolean vM returns nothing
	call (xM, wM, , vM)
	call (xM, wM, , vM)
	call (xM, wM, , vM)
	call (xM, wM, , vM)
	call (xM, wM, , vM)
endfunction

function yM takes player BM, player AM, boolean zM returns nothing
	call (BM, AM, , zM)
endfunction

function CM takes player FM, player EM, boolean DM returns nothing
	call (FM, EM, , DM)
endfunction

function GM takes player JM, player IM, boolean HM returns nothing
	call (JM, IM, , HM)
endfunction

function KM takes player NM, player MM, integer LM returns nothing
	if (NM == MM) then
		return
	endif
	if LM == Xd then
		call uM(NM, MM, false)
		call yM(NM, MM, false)
		call CM(NM, MM, false)
		call GM(NM, MM, false)
	elseif LM == Xd then
		call uM(NM, MM, false)
		call yM(NM, MM, true)
		call CM(NM, MM, false)
		call GM(NM, MM, false)
	elseif LM == Xd then
		call uM(NM, MM, true)
		call yM(NM, MM, false)
		call CM(NM, MM, false)
		call GM(NM, MM, false)
	elseif LM == Xd then
		call uM(NM, MM, true)
		call yM(NM, MM, true)
		call CM(NM, MM, false)
		call GM(NM, MM, false)
	elseif LM == Xd then
		call uM(NM, MM, true)
		call yM(NM, MM, true)
		call CM(NM, MM, true)
		call GM(NM, MM, false)
	elseif LM == Xd then
		call uM(NM, MM, true)
		call yM(NM, MM, true)
		call CM(NM, MM, true)
		call GM(NM, MM, true)
	elseif LM == Xd then
		call uM(NM, MM, false)
		call yM(NM, MM, false)
		call CM(NM, MM, false)
		call GM(NM, MM, false)
		call (NM, MM, , true)
	elseif LM == Xd then
		call uM(NM, MM, false)
		call yM(NM, MM, true)
		call CM(NM, MM, false)
		call GM(NM, MM, false)
		call (NM, MM, , true)
	else
	endif
endfunction

function OM takes force TM, force SM, integer RM returns nothing
	local integer QM
	local integer PM
	set QM = 0
	loop
		if (TM == Tf or IsPlayerInForce(Player(QM), TM)) then
			set PM = 0
			loop
				if (SM == Tf or IsPlayerInForce(Player(PM), SM)) then
					call KM(Player(QM), Player(PM), RM)
				endif
				set PM = PM + 1
				exitwhen PM == G
			endloop
		endif
		set QM = QM + 1
		exitwhen QM == G
	endloop
endfunction

function UM takes player WM, player VM returns boolean
	if (WM == VM) then
		return true
	endif
	if GetPlayerAlliance(WM, VM, ) then
		if GetPlayerAlliance(VM, WM, ) then
			return true
		endif
	endif
	return false
endfunction

function XM takes player aN returns nothing
	local integer ZM
	local player YM
	set ZM = 0
	loop
		set YM = Player(ZM)
		if (UM(aN, YM) and aN != YM) then
			if (GetPlayerController(YM) == ) then
				call (aN, YM, , true)
				call (aN, YM, , true)
				call (aN, YM, , true)
			endif
		endif
		set ZM = ZM + 1
		exitwhen ZM == D
	endloop
endfunction

function bN takes player eN returns nothing
	local integer dN
	local player cN
	set dN = 0
	loop
		set cN = Player(dN)
		if (UM(eN, cN) and eN != cN) then
			call (eN, cN, , true)
			call (eN, cN, , true)
			call (cN, eN, , true)
			call (eN, cN, , true)
		endif
		set dN = dN + 1
		exitwhen dN == D
	endloop
endfunction

function fN takes nothing returns nothing
	local integer iN
	local player hN
	local player gN = Player(E)
	set iN = 0
	loop
		set hN = Player(iN)
		call (gN, hN, , true)
		call (hN, gN, , false)
		set iN = iN + 1
		exitwhen iN == D
	endloop
	set hN = Player()
	call (gN, hN, , true)
	call (hN, gN, , true)
	call (gN, , 0)
endfunction

function jN takes nothing returns nothing
	call (GetEnumUnit(), Player(E), false)
endfunction

function kN takes player mN returns nothing
	local group lN = CreateGroup()
	call (mN)
	call (lN, mN, null)
	call (lN, function )
	call (lN)
endfunction

function nN takes player qN returns nothing
	local integer pN
	local player oN
	set pN = 0
	loop
		set oN = Player(pN)
		if UM(qN, oN) then
			call kN(oN)
		endif
		set pN = pN + 1
		exitwhen pN == D
	endloop
endfunction

function rN takes playergameresult sN returns boolean
	if (sN == ) then
		return not IsNoVictoryCheat()
	endif
	if (sN == ) then
		return not IsNoDefeatCheat()
	endif
	if (sN == ) then
		return (not IsNoVictoryCheat()) and (not IsNoDefeatCheat())
	endif
	return true
endfunction

function tN takes nothing returns nothing
	call (true)
endfunction

function uN takes player zN, boolean yN returns nothing
	local trigger xN = CreateTrigger()
	local dialog wN = DialogCreate()
	local string vN
	if (yN) then
		set vN = GetLocalizedString("PLAYER_LEFT_GAME")
	else
		set vN = GetLocalizedString("PLAYER_VICTORIOUS")
	endif
	call (zN, 0, 0, 60, vN)
	call (wN, GetLocalizedString("GAMEOVER_VICTORY_MSG"))
	call (wN, GetLocalizedString("GAMEOVER_CONTINUE_GAME"), GetLocalizedHotkey("GAMEOVER_CONTINUE_GAME"))
	set xN = CreateTrigger()
	call (xN, DialogAddQuitButton(wN, true, GetLocalizedString("GAMEOVER_QUIT_GAME"), GetLocalizedHotkey("GAMEOVER_QUIT_GAME")))
	call (zN, wN, true)
	call Fw(zN, Cg)
endfunction

function AN takes player FN, boolean EN returns nothing
	local trigger DN = CreateTrigger()
	local dialog CN = DialogCreate()
	local string BN
	if (EN) then
		set BN = GetLocalizedString("PLAYER_LEFT_GAME")
	else
		set BN = GetLocalizedString("PLAYER_DEFEATED")
	endif
	call (FN, 0, 0, 60, BN)
	call (CN, GetLocalizedString("GAMEOVER_DEFEAT_MSG"))
	if (not Rg and IsMapFlagSet()) then
		call (CN, GetLocalizedString("GAMEOVER_CONTINUE_OBSERVING"), GetLocalizedHotkey("GAMEOVER_CONTINUE_OBSERVING"))
	endif
	set DN = CreateTrigger()
	call (DN, DialogAddQuitButton(CN, true, GetLocalizedString("GAMEOVER_QUIT_GAME"), GetLocalizedHotkey("GAMEOVER_QUIT_GAME")))
	call (FN, CN, true)
	call Fw(FN, Dg)
endfunction

function GN takes player LN, boolean KN returns nothing
	local trigger JN = CreateTrigger()
	local dialog IN = DialogCreate()
	local string HN
	call (LN, 0, 0, 60, GetLocalizedString("PLAYER_LEFT_GAME"))
	if (GetIntegerGameState() != 0) then
		set HN = GetLocalizedString("GAMEOVER_DISCONNECTED")
	else
		set HN = GetLocalizedString("GAMEOVER_GAME_OVER")
	endif
	call (IN, HN)
	set JN = CreateTrigger()
	call (JN, DialogAddQuitButton(IN, true, GetLocalizedString("GAMEOVER_OK"), GetLocalizedHotkey("GAMEOVER_OK")))
	call (LN, IN, true)
	call Fw(LN, Dg)
endfunction

function MN takes player PN, playergameresult ON, boolean NN returns nothing
	if rN(ON) then
		call (PN, ON)
		if (ON == ) then
			call uN(PN, NN)
			return
		elseif (ON == ) then
			call AN(PN, NN)
		else
			call GN(PN, NN)
		endif
	endif
endfunction

function QN takes nothing returns nothing
	if ig then
		call (false)
		call (GetDefaultDifficulty())
	endif
	if (ji == null) then
		call (ii)
	else
		call (ji, ii)
	endif
endfunction

function RN takes nothing returns nothing
	if ig then
		call (false)
		call (GetDefaultDifficulty())
	endif
	call (ii)
endfunction

function SN takes player VN returns nothing
	local trigger UN = CreateTrigger()
	local dialog TN = DialogCreate()
	call (TN, GetLocalizedString("GAMEOVER_VICTORY_MSG"))
	set UN = CreateTrigger()
	call (UN, DialogAddButton(TN, GetLocalizedString("GAMEOVER_CONTINUE"), GetLocalizedHotkey("GAMEOVER_CONTINUE")))
	call (UN, function )
	set UN = CreateTrigger()
	call (UN, DialogAddButton(TN, GetLocalizedString("GAMEOVER_QUIT_MISSION"), GetLocalizedHotkey("GAMEOVER_QUIT_MISSION")))
	call (UN, function )
	if (GetLocalPlayer() == VN) then
		call (true)
		if ig then
			call (true)
		endif
		call (false)
	endif
	call (VN, TN, true)
	call Iw(VN, , 1.0)
	call Fw(VN, Cg)
endfunction

function WN takes player XN returns nothing
	if (GetLocalPlayer() == XN) then
		if ig then
			call (GetDefaultDifficulty())
		endif
		if (ji == null) then
			call (ii)
		else
			call (ji, ii)
		endif
	endif
endfunction

function YN takes player bO, boolean aO, boolean ZN returns nothing
	if rN() then
		call (bO, )
		if not ig then
			call (bO, 0, 0, 60, GetLocalizedString("PLAYER_VICTORIOUS"))
		endif
		if (GetPlayerController(bO) == ) then
			set ii = ZN
			if aO then
				call SN(bO)
			else
				call WN(bO)
			endif
		endif
	endif
endfunction

function cO takes nothing returns nothing
	call (false)
	call (true)
endfunction

function dO takes nothing returns nothing
	local gamedifficulty eO = GetGameDifficulty()
	call (false)
	if (eO == ) then
	elseif (eO == ) then
		call ()
	elseif (eO == ) then
		call ()
	else
	endif
	call (true)
endfunction

function fO takes nothing returns nothing
	call (false)
	call ()
endfunction

function gO takes nothing returns nothing
	if ig then
		call (false)
	endif
	call (GetDefaultDifficulty())
	call (true)
endfunction

function hO takes player lO, string kO returns nothing
	local trigger jO = CreateTrigger()
	local dialog iO = DialogCreate()
	call (iO, kO)
	if ig then
		set jO = CreateTrigger()
		call (jO, DialogAddButton(iO, GetLocalizedString("GAMEOVER_RESTART"), GetLocalizedHotkey("GAMEOVER_RESTART")))
		call (jO, function )
		if (GetGameDifficulty() != ) then
			set jO = CreateTrigger()
			call (jO, DialogAddButton(iO, GetLocalizedString("GAMEOVER_REDUCE_DIFFICULTY"), GetLocalizedHotkey("GAMEOVER_REDUCE_DIFFICULTY")))
			call (jO, function )
		endif
		set jO = CreateTrigger()
		call (jO, DialogAddButton(iO, GetLocalizedString("GAMEOVER_LOAD"), GetLocalizedHotkey("GAMEOVER_LOAD")))
		call (jO, function )
	endif
	set jO = CreateTrigger()
	call (jO, DialogAddButton(iO, GetLocalizedString("GAMEOVER_QUIT_MISSION"), GetLocalizedHotkey("GAMEOVER_QUIT_MISSION")))
	call (jO, function )
	if (GetLocalPlayer() == lO) then
		call (true)
		if ig then
			call (true)
		endif
		call (false)
	endif
	call (lO, iO, true)
	call Iw(lO, , 1.0)
	call Fw(lO, Dg)
endfunction

function mO takes player oO, string nO returns nothing
	if rN() then
		call (oO, )
		if not ig then
			call (oO, 0, 0, 60, GetLocalizedString("PLAYER_DEFEATED"))
		endif
		if (GetPlayerController(oO) == ) then
			call hO(oO, nO)
		endif
	endif
endfunction

function pO takes string qO returns nothing
	if (qO == "") then
		set ji = null
	else
		set ji = qO
	endif
endfunction

function rO takes boolean tO, player sO returns nothing
	call (sO, tO)
endfunction

function uO takes integer AO, string zO, string yO, string xO returns quest
	local boolean wO = (AO == qe) or (AO == re)
	local boolean vO = (AO == qe) or (AO == se)
	set Di = CreateQuest()
	call (Di, zO)
	call (Di, yO)
	call (Di, xO)
	call (Di, wO)
	call (Di, vO)
	call (Di, false)
	return Di
endfunction

function BO takes quest CO returns nothing
	call (CO)
endfunction

function DO takes boolean FO, quest EO returns nothing
	call (EO, FO)
endfunction

function GO takes quest IO, string HO returns nothing
	call (IO, HO)
endfunction

function JO takes quest LO, string KO returns nothing
	call (LO, KO)
endfunction

function MO takes quest OO, boolean NO returns nothing
	call (OO, NO)
endfunction

function PO takes quest RO, boolean QO returns nothing
	call (RO, QO)
endfunction

function SO takes quest UO, boolean TO returns nothing
	call (UO, TO)
endfunction

function VO takes nothing returns quest
	return Di
endfunction

function WO takes quest YO, string XO returns questitem
	set Ei = QuestCreateItem(YO)
	call (Ei, XO)
	call (Ei, false)
	return Ei
endfunction

function ZO takes questitem bP, string aP returns nothing
	call (bP, aP)
endfunction

function cP takes questitem eP, boolean dP returns nothing
	call (eP, dP)
endfunction

function fP takes nothing returns questitem
	return Ei
endfunction

function gP takes string hP returns defeatcondition
	set Fi = CreateDefeatCondition()
	call (Fi, hP)
	return Fi
endfunction

function iP takes defeatcondition jP returns nothing
	call (jP)
endfunction

function kP takes defeatcondition mP, string lP returns nothing
	call (mP, lP)
endfunction

function nP takes nothing returns defeatcondition
	return Fi
endfunction

function oP takes nothing returns nothing
	call ()
endfunction

function pP takes force sP, integer rP, string qP returns nothing
	if (IsPlayerInForce(GetLocalPlayer(), sP)) then
		if (rP == ue) then
			call (GetLocalPlayer(), 0, 0, h, " ")
			call (GetLocalPlayer(), 0, 0, h, qP)
			call (ug)
			call ()
		elseif (rP == ue) then
			call (GetLocalPlayer(), 0, 0, i, " ")
			call (GetLocalPlayer(), 0, 0, i, qP)
			call (vg)
			call ()
		elseif (rP == ue) then
			call (GetLocalPlayer(), 0, 0, j, " ")
			call (GetLocalPlayer(), 0, 0, j, qP)
			call (wg)
			call ()
		elseif (rP == ue) then
			call (GetLocalPlayer(), 0, 0, k, " ")
			call (GetLocalPlayer(), 0, 0, k, qP)
			call (xg)
			call ()
		elseif (rP == ue) then
			call (GetLocalPlayer(), 0, 0, l, qP)
		elseif (rP == ue) then
			call (GetLocalPlayer(), 0, 0, m, " ")
			call (GetLocalPlayer(), 0, 0, m, qP)
			call (xg)
		elseif (rP == ue) then
			call (GetLocalPlayer(), 0, 0, o, " ")
			call (GetLocalPlayer(), 0, 0, o, qP)
			call (yg)
		elseif (rP == ue) then
			call (GetLocalPlayer(), 0, 0, n, " ")
			call (GetLocalPlayer(), 0, 0, n, qP)
			call (yg)
		elseif (rP == ue) then
			call (GetLocalPlayer(), 0, 0, p, " ")
			call (GetLocalPlayer(), 0, 0, p, qP)
			call (zg)
		elseif (rP == ue) then
			call (GetLocalPlayer(), 0, 0, q, " ")
			call (GetLocalPlayer(), 0, 0, q, qP)
			call (yg)
		elseif (rP == ue) then
			call (GetLocalPlayer(), 0, 0, r, " ")
			call (GetLocalPlayer(), 0, 0, r, qP)
			call (yg)
		elseif (rP == ue) then
			call (GetLocalPlayer(), 0, 0, s, " ")
			call (GetLocalPlayer(), 0, 0, s, qP)
			call (Ag)
		elseif (rP == ue) then
			call (GetLocalPlayer(), 0, 0, t, " ")
			call (GetLocalPlayer(), 0, 0, t, qP)
			call (Bg)
		else
		endif
	endif
endfunction

function tP takes timer wP, boolean vP, real uP returns timer
	set Gi = wP
	call (wP, uP, vP, null)
	return Gi
endfunction

function xP takes boolean zP, real yP returns timer
	set Gi = CreateTimer()
	call (Gi, yP, zP, null)
	return Gi
endfunction

function AP takes timer BP returns nothing
	call (BP)
endfunction

function CP takes boolean EP, timer DP returns nothing
	if EP then
		call (DP)
	else
		call (DP)
	endif
endfunction

function FP takes nothing returns timer
	return Gi
endfunction

function GP takes timer IP, string HP returns timerdialog
	set Hi = CreateTimerDialog(IP)
	call (Hi, HP)
	call (Hi, true)
	return Hi
endfunction

function JP takes timerdialog KP returns nothing
	call (KP)
endfunction

function LP takes timerdialog NP, string MP returns nothing
	call (NP, MP)
endfunction

function OP takes timerdialog TP, real SP, real RP, real QP, real PP returns nothing
	call (TP, cm(SP), cm(RP), cm(QP), cm(100.0 - PP))
endfunction

function UP takes timerdialog ZP, real YP, real XP, real WP, real VP returns nothing
	call (ZP, cm(YP), cm(XP), cm(WP), cm(100.0 - VP))
endfunction

function aQ takes timerdialog cQ, real bQ returns nothing
	call (cQ, bQ)
endfunction

function dQ takes boolean gQ, timerdialog fQ, player eQ returns nothing
	if (GetLocalPlayer() == eQ) then
		call (fQ, gQ)
	endif
endfunction

function hQ takes boolean jQ, timerdialog iQ returns nothing
	call (iQ, jQ)
endfunction

function kQ takes nothing returns timerdialog
	return Hi
endfunction

function lQ takes leaderboard nQ returns nothing
	local integer mQ = LeaderboardGetItemCount(nQ)
	if (LeaderboardGetLabelText(nQ) == "") then
		set mQ = mQ - 1
	endif
	call (nQ, mQ)
endfunction

function oQ takes player rQ, leaderboard qQ, integer pQ returns nothing
	call (qQ, LeaderboardGetPlayerIndex(qQ, rQ), pQ)
endfunction

function sQ takes player vQ, leaderboard uQ, string tQ returns nothing
	call (uQ, LeaderboardGetPlayerIndex(uQ, vQ), tQ)
endfunction

function wQ takes player BQ, leaderboard AQ, boolean zQ, boolean yQ, boolean xQ returns nothing
	call (AQ, LeaderboardGetPlayerIndex(AQ, BQ), zQ, yQ, xQ)
endfunction

function CQ takes player IQ, leaderboard HQ, real GQ, real FQ, real EQ, real DQ returns nothing
	call (HQ, LeaderboardGetPlayerIndex(HQ, IQ), cm(GQ), cm(FQ), cm(EQ), cm(100.0 - DQ))
endfunction

function JQ takes player PQ, leaderboard OQ, real NQ, real MQ, real LQ, real KQ returns nothing
	call (OQ, LeaderboardGetPlayerIndex(OQ, PQ), cm(NQ), cm(MQ), cm(LQ), cm(100.0 - KQ))
endfunction

function QQ takes leaderboard VQ, real UQ, real TQ, real SQ, real RQ returns nothing
	call (VQ, cm(UQ), cm(TQ), cm(SQ), cm(100.0 - RQ))
endfunction

function WQ takes leaderboard bR, real aR, real ZQ, real YQ, real XQ returns nothing
	call (bR, cm(aR), cm(ZQ), cm(YQ), cm(100.0 - XQ))
endfunction

function cR takes leaderboard eR, string dR returns nothing
	call (eR, dR)
	call lQ(eR)
endfunction

function fR takes leaderboard kR, boolean jR, boolean iR, boolean hR, boolean gR returns nothing
	call (kR, jR, iR, hR, gR)
endfunction

function lR takes leaderboard mR returns integer
	return LeaderboardGetItemCount(mR)
endfunction

function nR takes leaderboard pR, player oR returns boolean
	return LeaderboardHasPlayerItem(pR, oR)
endfunction

function qR takes leaderboard uR, force tR returns nothing
	local integer sR
	local player rR
	set sR = 0
	loop
		set rR = Player(sR)
		if IsPlayerInForce(rR, tR) then
			call (rR, uR)
		endif
		set sR = sR + 1
		exitwhen sR == D
	endloop
endfunction

function vR takes force xR, string wR returns leaderboard
	set Ii = CreateLeaderboard()
	call (Ii, wR)
	call qR(Ii, xR)
	call (Ii, true)
	return Ii
endfunction

function yR takes leaderboard zR returns nothing
	call (zR)
endfunction

function AR takes boolean CR, leaderboard BR returns nothing
	call (BR, CR)
endfunction

function DR takes player HR, leaderboard GR, string FR, integer ER returns nothing
	if (LeaderboardHasPlayerItem(GR, HR)) then
		call (GR, HR)
	endif
	call (GR, FR, ER, HR)
	call lQ(GR)
endfunction

function IR takes player KR, leaderboard JR returns nothing
	call (JR, KR)
	call lQ(JR)
endfunction

function LR takes leaderboard OR, integer NR, boolean MR returns nothing
	if (NR == He) then
		call (OR, MR)
	elseif (NR == He) then
		call (OR, MR)
	elseif (NR == He) then
		call (OR, MR)
	else
	endif
endfunction

function PR takes leaderboard RR, boolean QR returns nothing
	call (RR, QR)
endfunction

function SR takes leaderboard UR, boolean TR returns nothing
	call (UR, TR)
endfunction

function VR takes player XR, leaderboard WR returns integer
	return LeaderboardGetPlayerIndex(WR, XR) + 1
endfunction

function YR takes integer cS, leaderboard bS returns player
	local integer aS
	local player ZR
	set aS = 0
	loop
		set ZR = Player(aS)
		if (LeaderboardGetPlayerIndex(bS, ZR) == cS - 1) then
			return ZR
		endif
		set aS = aS + 1
		exitwhen aS == D
	endloop
	return Player()
endfunction

function dS takes player eS returns leaderboard
	return PlayerGetLeaderboard(eS)
endfunction

function fS takes nothing returns leaderboard
	return Ii
endfunction

function gS takes integer jS, integer iS, string hS returns multiboard
	set Ji = CreateMultiboard()
	call (Ji, iS)
	call (Ji, jS)
	call (Ji, hS)
	call (Ji, true)
	return Ji
endfunction

function kS takes multiboard lS returns nothing
	call (lS)
endfunction

function mS takes nothing returns multiboard
	return Ji
endfunction

function nS takes boolean pS, multiboard oS returns nothing
	call (oS, pS)
endfunction

function qS takes boolean sS, multiboard rS returns nothing
	call (rS, sS)
endfunction

function tS takes multiboard yS, real xS, real wS, real vS, real uS returns nothing
	call (yS, cm(xS), cm(wS), cm(vS), cm(100.0 - uS))
endfunction

function zS takes boolean AS returns nothing
	call (not AS)
endfunction

function BS takes multiboard LS, integer KS, integer JS, boolean IS, boolean HS returns nothing
	local integer GS = 0
	local integer FS = 0
	local integer ES = MultiboardGetRowCount(LS)
	local integer DS = MultiboardGetColumnCount(LS)
	local multiboarditem CS = null
	loop
		set GS = GS + 1
		exitwhen GS > ES
		if (JS == 0 or JS == GS) then
			set FS = 0
			loop
				set FS = FS + 1
				exitwhen FS > DS
				if (KS == 0 or KS == FS) then
					set CS = MultiboardGetItem(LS, GS - 1, FS - 1)
					call (CS, IS, HS)
					call (CS)
				endif
			endloop
		endif
	endloop
endfunction

function MS takes multiboard VS, integer US, integer TS, string SS returns nothing
	local integer RS = 0
	local integer QS = 0
	local integer PS = MultiboardGetRowCount(VS)
	local integer OS = MultiboardGetColumnCount(VS)
	local multiboarditem NS = null
	loop
		set RS = RS + 1
		exitwhen RS > PS
		if (TS == 0 or TS == RS) then
			set QS = 0
			loop
				set QS = QS + 1
				exitwhen QS > OS
				if (US == 0 or US == QS) then
					set NS = MultiboardGetItem(VS, RS - 1, QS - 1)
					call (NS, SS)
					call (NS)
				endif
			endloop
		endif
	endloop
endfunction

function WS takes multiboard iT, integer hT, integer gT, real fT, real eT, real dT, real cT returns nothing
	local integer bT = 0
	local integer aT = 0
	local integer ZS = MultiboardGetRowCount(iT)
	local integer YS = MultiboardGetColumnCount(iT)
	local multiboarditem XS = null
	loop
		set bT = bT + 1
		exitwhen bT > ZS
		if (gT == 0 or gT == bT) then
			set aT = 0
			loop
				set aT = aT + 1
				exitwhen aT > YS
				if (hT == 0 or hT == aT) then
					set XS = MultiboardGetItem(iT, bT - 1, aT - 1)
					call (XS, cm(fT), cm(eT), cm(dT), cm(100.0 - cT))
					call (XS)
				endif
			endloop
		endif
	endloop
endfunction

function jT takes multiboard sT, integer rT, integer qT, real pT returns nothing
	local integer oT = 0
	local integer nT = 0
	local integer mT = MultiboardGetRowCount(sT)
	local integer lT = MultiboardGetColumnCount(sT)
	local multiboarditem kT = null
	loop
		set oT = oT + 1
		exitwhen oT > mT
		if (qT == 0 or qT == oT) then
			set nT = 0
			loop
				set nT = nT + 1
				exitwhen nT > lT
				if (rT == 0 or rT == nT) then
					set kT = MultiboardGetItem(sT, oT - 1, nT - 1)
					call (kT, pT / 100.0)
					call (kT)
				endif
			endloop
		endif
	endloop
endfunction

function tT takes multiboard CT, integer BT, integer AT, string zT returns nothing
	local integer yT = 0
	local integer xT = 0
	local integer wT = MultiboardGetRowCount(CT)
	local integer vT = MultiboardGetColumnCount(CT)
	local multiboarditem uT = null
	loop
		set yT = yT + 1
		exitwhen yT > wT
		if (AT == 0 or AT == yT) then
			set xT = 0
			loop
				set xT = xT + 1
				exitwhen xT > vT
				if (BT == 0 or BT == xT) then
					set uT = MultiboardGetItem(CT, yT - 1, xT - 1)
					call (uT, zT)
					call (uT)
				endif
			endloop
		endif
	endloop
endfunction

function DT takes real ET returns real
	return ET * 0.023 / 10
endfunction

function FT takes real GT returns real
	return GT * 0.071 / 128
endfunction

function HT takes texttag MT, real LT, real KT, real JT, real IT returns nothing
	call (MT, cm(LT), cm(KT), cm(JT), cm(100.0 - IT))
endfunction

function NT takes texttag TT, real ST, real RT returns nothing
	local real QT = FT(ST)
	local real PT = QT * Cos(RT * g)
	local real OT = QT * Sin(RT * g)
	call (TT, PT, OT)
endfunction

function UT takes texttag YT, string XT, real WT returns nothing
	local real VT = DT(WT)
	call (YT, XT, VT)
endfunction

function ZT takes texttag cU, location bU, real aU returns nothing
	call (cU, GetLocationX(bU), GetLocationY(bU), aU)
endfunction

function dU takes texttag gU, unit fU, real eU returns nothing
	call (gU, fU, eU)
endfunction

function hU takes texttag jU, boolean iU returns nothing
	call (jU, iU)
endfunction

function kU takes texttag mU, boolean lU returns nothing
	call (mU, lU)
endfunction

function nU takes texttag pU, real oU returns nothing
	call (pU, oU)
endfunction

function qU takes texttag sU, real rU returns nothing
	call (sU, rU)
endfunction

function tU takes texttag vU, real uU returns nothing
	call (vU, uU)
endfunction

function wU takes string EU, location DU, real CU, real BU, real AU, real zU, real yU, real xU returns texttag
	set Si = CreateTextTag()
	call UT(Si, EU, BU)
	call ZT(Si, DU, CU)
	call HT(Si, AU, zU, yU, xU)
	return Si
endfunction

function FU takes string NU, unit MU, real LU, real KU, real JU, real IU, real HU, real GU returns texttag
	set Si = CreateTextTag()
	call UT(Si, NU, KU)
	call dU(Si, MU, LU)
	call HT(Si, JU, IU, HU, GU)
	return Si
endfunction

function OU takes texttag PU returns nothing
	call (PU)
endfunction

function QU takes boolean TU, texttag SU, force RU returns nothing
	if (IsPlayerInForce(GetLocalPlayer(), RU)) then
		call (SU, TU)
	endif
endfunction

function UU takes nothing returns texttag
	return Si
endfunction

function VU takes nothing returns nothing
	call (true)
endfunction

function WU takes nothing returns nothing
	call (false)
endfunction

function XU takes force YU returns nothing
	if (IsPlayerInForce(GetLocalPlayer(), YU)) then
		call (true)
	endif
endfunction

function ZU takes force aV returns nothing
	if (IsPlayerInForce(GetLocalPlayer(), aV)) then
		call (false)
	endif
endfunction

function bV takes force dV, real cV returns nothing
	if (IsPlayerInForce(GetLocalPlayer(), dV)) then
		call (true, cV)
	endif
endfunction

function eV takes force gV, real fV returns nothing
	if (IsPlayerInForce(GetLocalPlayer(), gV)) then
		call (false, fV)
	endif
endfunction

function hV takes force lV, real kV, real jV, real iV returns nothing
	if (IsPlayerInForce(GetLocalPlayer(), lV)) then
		call (kV, jV, iV)
	endif
endfunction

function mV takes force pV, location oV, real nV returns nothing
	call hV(pV, GetLocationX(oV), GetLocationY(oV), nV)
endfunction

function qV takes player uV, real tV, real sV, real rV returns nothing
	if (GetLocalPlayer() == uV) then
		call (tV, sV, rV)
	endif
endfunction

function vV takes player yV, location xV, real wV returns nothing
	call qV(yV, GetLocationX(xV), GetLocationY(xV), wV)
endfunction

function zV takes force KV, real JV, real IV, real HV, integer GV, real FV, real EV, real DV returns nothing
	local integer CV = cm(FV)
	local integer BV = cm(EV)
	local integer AV = cm(DV)
	if (IsPlayerInForce(GetLocalPlayer(), KV)) then
		if (CV == 255) and (BV == 0) and (AV == 0) then
			set CV = 254
		endif
		if (GV == Ff) then
			call (JV, IV, HV, CV, BV, AV, false)
		elseif (GV == Ff) then
			call (JV, IV, HV, CV, BV, AV, true)
		elseif (GV == Ff) then
			call (JV, IV, HV, 255, 0, 0, false)
		else
		endif
	endif
endfunction

function LV takes force SV, location RV, real QV, integer PV, real OV, real NV, real MV returns nothing
	call zV(SV, GetLocationX(RV), GetLocationY(RV), QV, PV, OV, NV, MV)
endfunction

function TV takes boolean VV, force UV returns nothing
	if (IsPlayerInForce(GetLocalPlayer(), UV)) then
		call (VV)
	endif
endfunction

function WV takes boolean YV, force XV returns nothing
	if (IsPlayerInForce(GetLocalPlayer(), XV)) then
		call (YV)
	endif
endfunction

function ZV takes nothing returns nothing
	call Ou(gh, true)
	call ()
endfunction

function aW takes nothing returns nothing
	local integer bW
	if (hh == null) then
		set hh = CreateTrigger()
		set bW = 0
		loop
			call (hh, Player(bW), )
			set bW = bW + 1
			exitwhen bW == D
		endloop
		call (hh, function )
	endif
endfunction

function cW takes sound jW, integer iW, playercolor hW, string gW, string fW, real eW, real dW returns nothing
	set gh = jW
	call Mu(jW)
	call (iW, hW, gW, fW, eW, dW)
endfunction

function kW takes sound oW, integer nW, real mW returns real
	local real lW
	if (nW == le) then
		set lW = Zv(oW) + mW
	elseif (nW == le) then
		set lW = mW
	elseif (nW == le) then
		set lW = Zv(oW) - mW
	else
		set lW = Zv(oW)
	endif
	if (lW < 0) then
		set lW = 0
	endif
	return lW
endfunction

function pW takes sound sW, integer rW, real qW returns nothing
	if (rW == me) then
		call (qW)
	elseif (rW == me) then
		call (ob)
	elseif (rW == me) then
		call qw(sW, qW)
	elseif (rW == me) then
		call qw(sW, 0)
		call (qW)
	else
	endif
endfunction

function tW takes integer BW, playercolor AW, real zW, real yW, sound xW, string wW, string vW, real uW returns nothing
	call cW(xW, BW, AW, wW, vW, uW + ub, uW)
	if (BW != 0) then
		call (zW, yW, pb)
	endif
endfunction

function CW takes force KW, unit JW, string IW, sound HW, string GW, integer FW, real EW, boolean DW returns nothing
	call aW()
	set EW = kj(EW, 0)
	set Mi = kW(HW, FW, EW)
	set Ki = HW
	if (IsPlayerInForce(GetLocalPlayer(), KW)) then
		if (JW == null) then
			call tW(0, , 0, 0, HW, IW, GW, Mi)
		else
			call tW(GetUnitTypeId(JW), GetPlayerColor(GetOwningPlayer(JW)), GetUnitX(JW), GetUnitY(JW), HW, IW, GW, Mi)
			if (not IsUnitHidden(JW)) then
				call (JW, qb, rb, sb, tb)
			endif
		endif
	endif
	if DW and (Mi > 0) then
		call pW(HW, FW, EW)
	endif
endfunction

function LW takes force VW, player UW, integer TW, string SW, location RW, sound QW, string PW, integer OW, real NW, boolean MW returns nothing
	call aW()
	set NW = kj(NW, 0)
	set Mi = kW(QW, OW, NW)
	set Ki = QW
	if (IsPlayerInForce(GetLocalPlayer(), VW)) then
		call tW(TW, GetPlayerColor(UW), GetLocationX(RW), GetLocationY(RW), QW, SW, PW, Mi)
	endif
	if MW and (Mi > 0) then
		call pW(QW, OW, NW)
	endif
endfunction

function WW takes nothing returns real
	return Mi
endfunction

function XW takes boolean YW returns nothing
	call (YW)
endfunction

function ZW takes boolean cX, force bX, real aX returns nothing
	if (not gg) then
		set aX = 0
	endif
	if (cX) then
		if (not lh) then
			set lh = true
			set ih = GetGameSpeed()
			set jh = IsFogEnabled()
			set kh = IsFogMaskEnabled()
			set mh = Ow()
			set nh = GetRandomInt(0, 1000000)
		endif
		if (IsPlayerInForce(GetLocalPlayer(), bX)) then
			call ()
			call (false, aX)
			call (false)
			call (false)
			call jw()
		endif
		call (wb)
		call (, true)
		call (false)
		call (false)
		call (false)
		call Mw(false)
		call (0)
	else
		set lh = false
		if (IsPlayerInForce(GetLocalPlayer(), bX)) then
			call (true, aX)
			call (true)
			call (true)
			call ()
			call ()
			call Zo()
		endif
		call (, false)
		call (ih)
		call (kh)
		call (jh)
		call (true)
		call Mw(mh)
		call (nh)
	endif
endfunction

function dX takes boolean fX, force eX returns nothing
	call ZW(fX, eX, vb)
endfunction

function gX takes boolean hX returns nothing
	call (hX)
endfunction

function iX takes real pX, real oX, real nX, real mX, string lX, real kX, real jX returns nothing
	if (mX == 0) then
		set kX = jX
	endif
	call (false)
	call (lX)
	call ()
	call ()
	call (0, 0, 1, 1)
	call (0, 0, 1, 1)
	call (cm(pX), cm(oX), cm(nX), cm(100 - kX))
	call (cm(pX), cm(oX), cm(nX), cm(100 - jX))
	call (mX)
	call (true)
endfunction

function qX takes nothing returns nothing
	call (oh)
	set oh = null
	call (false)
	call (true)
endfunction

function rX takes real sX returns nothing
	set oh = CreateTimer()
	call (oh, sX, false, function )
endfunction

function tX takes nothing returns nothing
	call (ph)
	set ph = null
	call iX(qh, rh, sh, uh, vh, th, 100)
endfunction

function uX takes real AX, real zX, real yX, real xX, real wX, string vX returns nothing
	set qh = zX
	set rh = yX
	set sh = xX
	set th = wX
	set uh = AX
	set vh = vX
	set ph = CreateTimer()
	call (ph, AX, false, function )
endfunction

function BX takes nothing returns nothing
	if (ph != null) then
		call (ph)
	endif
	if (oh != null) then
		call (oh)
	endif
endfunction

function CX takes integer JX, real IX, string HX, real GX, real FX, real EX, real DX returns nothing
	if (JX == Le) then
		call BX()
		call iX(GX, FX, EX, IX, HX, 100, DX)
	elseif (JX == Le) then
		call BX()
		call iX(GX, FX, EX, IX, HX, DX, 100)
		call rX(IX)
	elseif (JX == Le) then
		if (IX > 0) then
			call BX()
			call iX(GX, FX, EX, IX * 0.5, HX, 100, DX)
			call uX(IX * 0.5, GX, FX, EX, DX, HX)
			call rX(IX)
		endif
	else
	endif
endfunction

function KX takes real VX, blendmode UX, string TX, real SX, real RX, real QX, real PX, real OX, real NX, real MX, real LX returns nothing
	call BX()
	call (TX)
	call (UX)
	call ()
	call (0, 0, 1, 1)
	call (0, 0, 1, 1)
	call (cm(SX), cm(RX), cm(QX), cm(100 - PX))
	call (cm(OX), cm(NX), cm(MX), cm(100 - LX))
	call (VX)
	call (true)
endfunction

function WX takes unit ZX, player YX, boolean XX returns nothing
	if yC(ZX) or (GetOwningPlayer(ZX) == YX) then
		return
	endif
	call (tg)
	call (ZX, YX, XX)
	call (ZX, 0, 255, 0, 255)
	call qV(YX, GetUnitX(ZX), GetUnitY(ZX), nb)
endfunction

function aY takes nothing returns nothing
	local unit bY = GetTriggerUnit()
	if IsUnitType(bY, ) then
		call WX(bY, GetOwningPlayer(GetRescuer()), eh)
	else
		call WX(bY, GetOwningPlayer(GetRescuer()), dh)
	endif
endfunction

function cY takes nothing returns nothing
	local integer dY
	if (ch == null) then
		set ch = CreateTrigger()
		set dY = 0
		loop
			call (ch, Player(dY), , null)
			set dY = dY + 1
			exitwhen dY == G
		endloop
		call (ch, function )
	endif
endfunction

function eY takes boolean fY returns nothing
	set dh = fY
endfunction

function gY takes boolean hY returns nothing
	set eh = hY
endfunction

function iY takes nothing returns nothing
	call cY()
	call (Yh, GetEnumPlayer(), Zh)
endfunction

function jY takes unit mY, boolean lY, force kY returns nothing
	set Yh = mY
	set Zh = lY
	call (kY, function )
endfunction

function nY takes nothing returns nothing
	local integer oY
	set oY = 0
	loop
		if (GetPlayerController(Player(oY)) == ) then
			call cY()
			return
		endif
		set oY = oY + 1
		exitwhen oY == D
	endloop
endfunction

function pY takes integer sY, integer rY, player qY returns nothing
	call (qY, sY, rY)
endfunction

function tY takes integer wY, integer vY, player uY returns nothing
	call (uY, wY, vY)
endfunction

function xY takes integer zY, player yY returns nothing
	call (yY, 'HERO', zY)
endfunction

function AY takes integer CY, player BY returns integer
	return GetPlayerTechCount(BY, CY, true)
endfunction

function DY takes integer FY, player EY returns integer
	return GetPlayerTechMaxAllowed(EY, FY)
endfunction

function GY takes boolean JY, integer IY, player HY returns nothing
	call (HY, IY, JY)
endfunction

function KY takes integer LY returns nothing
	if (LY == Rb) then
		call ()
	elseif (LY == Rb) then
		call ()
	elseif (LY == Rb) then
		call ()
	elseif (LY == Rb) then
		call ()
	elseif (LY == Rb) then
		call ()
	elseif (LY == Rb) then
		call (fc)
	elseif (LY == Rb) then
		call (gc)
	elseif (LY == Rb) then
		call (hc)
	elseif (LY == Rb) then
		call (ic)
	else
	endif
endfunction

function MY takes boolean QY, integer PY returns nothing
	local integer OY = PY / 1000
	local integer NY = PY - OY * 1000
	call (OY, NY, QY)
endfunction

function RY takes boolean UY, integer TY returns nothing
	local integer SY
	if (TY == Sb) then
		call (true)
	endif
	if (TY == Wb) then
		set SY = fc
	elseif (TY == Wb) then
		set SY = gc
	elseif (TY == Wb) then
		set SY = hc
	elseif (TY == Wb) then
		set SY = ic
	else
		set SY = TY
	endif
	call (SY, UY)
	call KY(TY)
	call ()
endfunction

function VY takes boolean XY, integer WY returns nothing
	if (WY == Md) then
		call (Rb, XY)
		call ("TutorialOp")
	elseif (WY == Md) then
		call (Sb, XY)
		call ("HumanOp")
	elseif (WY == Md) then
		call (Sb, XY)
		call ("HumanEd")
	elseif (WY == Md) then
		call (Ub, XY)
		call ("OrcOp")
	elseif (WY == Md) then
		call (Ub, XY)
		call ("OrcEd")
	elseif (WY == Md) then
		call (Tb, XY)
		call ("UndeadOp")
	elseif (WY == Md) then
		call (Tb, XY)
		call ("UndeadEd")
	elseif (WY == Md) then
		call (Vb, XY)
		call ("NightElfOp")
	elseif (WY == Md) then
		call (Vb, XY)
		call ("NightElfEd")
	elseif (WY == Md) then
		call (fc, XY)
		call ("IntroX")
	elseif (WY == Md) then
		call (hc, XY)
		call ("OutroX")
	else
	endif
endfunction

function YY takes string ZY returns gamecache
	set Ni = InitGameCache(ZY)
	return Ni
endfunction

function aZ takes gamecache bZ returns boolean
	return SaveGameCache(bZ)
endfunction

function cZ takes nothing returns gamecache
	return Ni
endfunction

function dZ takes nothing returns hashtable
	set Oi = InitHashtable()
	return Oi
endfunction

function eZ takes nothing returns hashtable
	return Oi
endfunction

function fZ takes real jZ, string iZ, string hZ, gamecache gZ returns nothing
	call (gZ, hZ, iZ, jZ)
endfunction

function kZ takes integer oZ, string nZ, string mZ, gamecache lZ returns nothing
	call (lZ, mZ, nZ, oZ)
endfunction

function pZ takes boolean tZ, string sZ, string rZ, gamecache qZ returns nothing
	call (qZ, rZ, sZ, tZ)
endfunction

function uZ takes string yZ, string xZ, string wZ, gamecache vZ returns boolean
	return StoreString(vZ, wZ, xZ, yZ)
endfunction

function zZ takes unit DZ, string CZ, string BZ, gamecache AZ returns boolean
	return StoreUnit(AZ, BZ, CZ, DZ)
endfunction

function EZ takes real IZ, integer HZ, integer GZ, hashtable FZ returns nothing
	call (FZ, GZ, HZ, IZ)
endfunction

function JZ takes integer NZ, integer MZ, integer LZ, hashtable KZ returns nothing
	call (KZ, LZ, MZ, NZ)
endfunction

function OZ takes boolean SZ, integer RZ, integer QZ, hashtable PZ returns nothing
	call (PZ, QZ, RZ, SZ)
endfunction

function TZ takes string XZ, integer WZ, integer VZ, hashtable UZ returns boolean
	return SaveStr(UZ, VZ, WZ, XZ)
endfunction

function YZ takes player c0, integer b0, integer a0, hashtable ZZ returns boolean
	return SavePlayerHandle(ZZ, a0, b0, c0)
endfunction

function d0 takes widget h0, integer g0, integer f0, hashtable e0 returns boolean
	return SaveWidgetHandle(e0, f0, g0, h0)
endfunction

function i0 takes destructable m0, integer l0, integer k0, hashtable j0 returns boolean
	return SaveDestructableHandle(j0, k0, l0, m0)
endfunction

function n0 takes item r0, integer q0, integer p0, hashtable o0 returns boolean
	return SaveItemHandle(o0, p0, q0, r0)
endfunction

function s0 takes unit w0, integer v0, integer u0, hashtable t0 returns boolean
	return SaveUnitHandle(t0, u0, v0, w0)
endfunction

function x0 takes ability B0, integer A0, integer z0, hashtable y0 returns boolean
	return SaveAbilityHandle(y0, z0, A0, B0)
endfunction

function C0 takes timer G0, integer F0, integer E0, hashtable D0 returns boolean
	return SaveTimerHandle(D0, E0, F0, G0)
endfunction

function H0 takes trigger L0, integer K0, integer J0, hashtable I0 returns boolean
	return SaveTriggerHandle(I0, J0, K0, L0)
endfunction

function M0 takes triggercondition Q0, integer P0, integer O0, hashtable N0 returns boolean
	return SaveTriggerConditionHandle(N0, O0, P0, Q0)
endfunction

function R0 takes triggeraction V0, integer U0, integer T0, hashtable S0 returns boolean
	return SaveTriggerActionHandle(S0, T0, U0, V0)
endfunction

function W0 takes event a1, integer Z0, integer Y0, hashtable X0 returns boolean
	return SaveTriggerEventHandle(X0, Y0, Z0, a1)
endfunction

function b1 takes force f1, integer e1, integer d1, hashtable c1 returns boolean
	return SaveForceHandle(c1, d1, e1, f1)
endfunction

function g1 takes group k1, integer j1, integer i1, hashtable h1 returns boolean
	return SaveGroupHandle(h1, i1, j1, k1)
endfunction

function l1 takes location p1, integer o1, integer n1, hashtable m1 returns boolean
	return SaveLocationHandle(m1, n1, o1, p1)
endfunction

function q1 takes rect u1, integer t1, integer s1, hashtable r1 returns boolean
	return SaveRectHandle(r1, s1, t1, u1)
endfunction

function v1 takes boolexpr z1, integer y1, integer x1, hashtable w1 returns boolean
	return SaveBooleanExprHandle(w1, x1, y1, z1)
endfunction

function A1 takes sound E1, integer D1, integer C1, hashtable B1 returns boolean
	return SaveSoundHandle(B1, C1, D1, E1)
endfunction

function F1 takes effect J1, integer I1, integer H1, hashtable G1 returns boolean
	return SaveEffectHandle(G1, H1, I1, J1)
endfunction

function K1 takes unitpool O1, integer N1, integer M1, hashtable L1 returns boolean
	return SaveUnitPoolHandle(L1, M1, N1, O1)
endfunction

function P1 takes itempool T1, integer S1, integer R1, hashtable Q1 returns boolean
	return SaveItemPoolHandle(Q1, R1, S1, T1)
endfunction

function U1 takes quest Y1, integer X1, integer W1, hashtable V1 returns boolean
	return SaveQuestHandle(V1, W1, X1, Y1)
endfunction

function Z1 takes questitem d2, integer c2, integer b2, hashtable a2 returns boolean
	return SaveQuestItemHandle(a2, b2, c2, d2)
endfunction

function e2 takes defeatcondition i2, integer h2, integer g2, hashtable f2 returns boolean
	return SaveDefeatConditionHandle(f2, g2, h2, i2)
endfunction

function j2 takes timerdialog n2, integer m2, integer l2, hashtable k2 returns boolean
	return SaveTimerDialogHandle(k2, l2, m2, n2)
endfunction

function o2 takes leaderboard s2, integer r2, integer q2, hashtable p2 returns boolean
	return SaveLeaderboardHandle(p2, q2, r2, s2)
endfunction

function t2 takes multiboard x2, integer w2, integer v2, hashtable u2 returns boolean
	return SaveMultiboardHandle(u2, v2, w2, x2)
endfunction

function y2 takes multiboarditem C2, integer B2, integer A2, hashtable z2 returns boolean
	return SaveMultiboardItemHandle(z2, A2, B2, C2)
endfunction

function D2 takes trackable H2, integer G2, integer F2, hashtable E2 returns boolean
	return SaveTrackableHandle(E2, F2, G2, H2)
endfunction

function I2 takes dialog M2, integer L2, integer K2, hashtable J2 returns boolean
	return SaveDialogHandle(J2, K2, L2, M2)
endfunction

function N2 takes button R2, integer Q2, integer P2, hashtable O2 returns boolean
	return SaveButtonHandle(O2, P2, Q2, R2)
endfunction

function S2 takes texttag W2, integer V2, integer U2, hashtable T2 returns boolean
	return SaveTextTagHandle(T2, U2, V2, W2)
endfunction

function X2 takes lightning b3, integer a3, integer Z2, hashtable Y2 returns boolean
	return SaveLightningHandle(Y2, Z2, a3, b3)
endfunction

function c3 takes image g3, integer f3, integer e3, hashtable d3 returns boolean
	return SaveImageHandle(d3, e3, f3, g3)
endfunction

function h3 takes ubersplat l3, integer k3, integer j3, hashtable i3 returns boolean
	return SaveUbersplatHandle(i3, j3, k3, l3)
endfunction

function m3 takes region q3, integer p3, integer o3, hashtable n3 returns boolean
	return SaveRegionHandle(n3, o3, p3, q3)
endfunction

function r3 takes fogstate v3, integer u3, integer t3, hashtable s3 returns boolean
	return SaveFogStateHandle(s3, t3, u3, v3)
endfunction

function w3 takes fogmodifier A3, integer z3, integer y3, hashtable x3 returns boolean
	return SaveFogModifierHandle(x3, y3, z3, A3)
endfunction

function B3 takes agent F3, integer E3, integer D3, hashtable C3 returns boolean
	return SaveAgentHandle(C3, D3, E3, F3)
endfunction

function G3 takes hashtable K3, integer J3, integer I3, hashtable H3 returns boolean
	return SaveHashtableHandle(H3, I3, J3, K3)
endfunction

function L3 takes string O3, string N3, gamecache M3 returns real
	return GetStoredReal(M3, N3, O3)
endfunction

function P3 takes string S3, string R3, gamecache Q3 returns integer
	return GetStoredInteger(Q3, R3, S3)
endfunction

function T3 takes string W3, string V3, gamecache U3 returns boolean
	return GetStoredBoolean(U3, V3, W3)
endfunction

function X3 takes string b4, string a4, gamecache Z3 returns string
	local string Y3
	set Y3 = GetStoredString(Z3, a4, b4)
	if (Y3 == null) then
		return ""
	else
		return Y3
	endif
endfunction

function c4 takes integer f4, integer e4, hashtable d4 returns real
	return LoadReal(d4, e4, f4)
endfunction

function g4 takes integer j4, integer i4, hashtable h4 returns integer
	return LoadInteger(h4, i4, j4)
endfunction

function k4 takes integer n4, integer m4, hashtable l4 returns boolean
	return LoadBoolean(l4, m4, n4)
endfunction

function o4 takes integer s4, integer r4, hashtable q4 returns string
	local string p4
	set p4 = LoadStr(q4, r4, s4)
	if (p4 == null) then
		return ""
	else
		return p4
	endif
endfunction

function t4 takes integer w4, integer v4, hashtable u4 returns player
	return LoadPlayerHandle(u4, v4, w4)
endfunction

function x4 takes integer A4, integer z4, hashtable y4 returns widget
	return LoadWidgetHandle(y4, z4, A4)
endfunction

function B4 takes integer E4, integer D4, hashtable C4 returns destructable
	return LoadDestructableHandle(C4, D4, E4)
endfunction

function F4 takes integer I4, integer H4, hashtable G4 returns item
	return LoadItemHandle(G4, H4, I4)
endfunction

function J4 takes integer M4, integer L4, hashtable K4 returns unit
	return LoadUnitHandle(K4, L4, M4)
endfunction

function N4 takes integer Q4, integer P4, hashtable O4 returns ability
	return LoadAbilityHandle(O4, P4, Q4)
endfunction

function R4 takes integer U4, integer T4, hashtable S4 returns timer
	return LoadTimerHandle(S4, T4, U4)
endfunction

function V4 takes integer Y4, integer X4, hashtable W4 returns trigger
	return LoadTriggerHandle(W4, X4, Y4)
endfunction

function Z4 takes integer c5, integer b5, hashtable a5 returns triggercondition
	return LoadTriggerConditionHandle(a5, b5, c5)
endfunction

function d5 takes integer g5, integer f5, hashtable e5 returns triggeraction
	return LoadTriggerActionHandle(e5, f5, g5)
endfunction

function h5 takes integer k5, integer j5, hashtable i5 returns event
	return LoadTriggerEventHandle(i5, j5, k5)
endfunction

function l5 takes integer o5, integer n5, hashtable m5 returns force
	return LoadForceHandle(m5, n5, o5)
endfunction

function p5 takes integer s5, integer r5, hashtable q5 returns group
	return LoadGroupHandle(q5, r5, s5)
endfunction

function t5 takes integer w5, integer v5, hashtable u5 returns location
	return LoadLocationHandle(u5, v5, w5)
endfunction

function x5 takes integer A5, integer z5, hashtable y5 returns rect
	return LoadRectHandle(y5, z5, A5)
endfunction

function B5 takes integer E5, integer D5, hashtable C5 returns boolexpr
	return LoadBooleanExprHandle(C5, D5, E5)
endfunction

function F5 takes integer I5, integer H5, hashtable G5 returns sound
	return LoadSoundHandle(G5, H5, I5)
endfunction

function J5 takes integer M5, integer L5, hashtable K5 returns effect
	return LoadEffectHandle(K5, L5, M5)
endfunction

function N5 takes integer Q5, integer P5, hashtable O5 returns unitpool
	return LoadUnitPoolHandle(O5, P5, Q5)
endfunction

function R5 takes integer U5, integer T5, hashtable S5 returns itempool
	return LoadItemPoolHandle(S5, T5, U5)
endfunction

function V5 takes integer Y5, integer X5, hashtable W5 returns quest
	return LoadQuestHandle(W5, X5, Y5)
endfunction

function Z5 takes integer c6, integer b6, hashtable a6 returns questitem
	return LoadQuestItemHandle(a6, b6, c6)
endfunction

function d6 takes integer g6, integer f6, hashtable e6 returns defeatcondition
	return LoadDefeatConditionHandle(e6, f6, g6)
endfunction

function h6 takes integer k6, integer j6, hashtable i6 returns timerdialog
	return LoadTimerDialogHandle(i6, j6, k6)
endfunction

function l6 takes integer o6, integer n6, hashtable m6 returns leaderboard
	return LoadLeaderboardHandle(m6, n6, o6)
endfunction

function p6 takes integer s6, integer r6, hashtable q6 returns multiboard
	return LoadMultiboardHandle(q6, r6, s6)
endfunction

function t6 takes integer w6, integer v6, hashtable u6 returns multiboarditem
	return LoadMultiboardItemHandle(u6, v6, w6)
endfunction

function x6 takes integer A6, integer z6, hashtable y6 returns trackable
	return LoadTrackableHandle(y6, z6, A6)
endfunction

function B6 takes integer E6, integer D6, hashtable C6 returns dialog
	return LoadDialogHandle(C6, D6, E6)
endfunction

function F6 takes integer I6, integer H6, hashtable G6 returns button
	return LoadButtonHandle(G6, H6, I6)
endfunction

function J6 takes integer M6, integer L6, hashtable K6 returns texttag
	return LoadTextTagHandle(K6, L6, M6)
endfunction

function N6 takes integer Q6, integer P6, hashtable O6 returns lightning
	return LoadLightningHandle(O6, P6, Q6)
endfunction

function R6 takes integer U6, integer T6, hashtable S6 returns image
	return LoadImageHandle(S6, T6, U6)
endfunction

function V6 takes integer Y6, integer X6, hashtable W6 returns ubersplat
	return LoadUbersplatHandle(W6, X6, Y6)
endfunction

function Z6 takes integer c7, integer b7, hashtable a7 returns region
	return LoadRegionHandle(a7, b7, c7)
endfunction

function d7 takes integer g7, integer f7, hashtable e7 returns fogstate
	return LoadFogStateHandle(e7, f7, g7)
endfunction

function h7 takes integer k7, integer j7, hashtable i7 returns fogmodifier
	return LoadFogModifierHandle(i7, j7, k7)
endfunction

function l7 takes integer o7, integer n7, hashtable m7 returns hashtable
	return LoadHashtableHandle(m7, n7, o7)
endfunction

function p7 takes string v7, string u7, gamecache t7, player s7, location r7, real q7 returns unit
	set Pi = RestoreUnit(t7, u7, v7, s7, GetLocationX(r7), GetLocationY(r7), q7)
	return Pi
endfunction

function w7 takes string C7, string B7, gamecache A7, player z7, location y7, location x7 returns unit
	return p7(C7, B7, A7, z7, y7, Qj(y7, x7))
endfunction

function D7 takes nothing returns unit
	return Pi
endfunction

function E7 takes gamecache F7 returns nothing
	call (F7)
endfunction

function G7 takes string I7, gamecache H7 returns nothing
	call (H7, I7)
endfunction

function J7 takes hashtable K7 returns nothing
	call (K7)
endfunction

function L7 takes integer N7, hashtable M7 returns nothing
	call (M7, N7)
endfunction

function O7 takes string S7, integer R7, string Q7, gamecache P7 returns boolean
	if (R7 == mf) then
		return HaveStoredBoolean(P7, Q7, S7)
	elseif (R7 == mf) then
		return HaveStoredInteger(P7, Q7, S7)
	elseif (R7 == mf) then
		return HaveStoredReal(P7, Q7, S7)
	elseif (R7 == mf) then
		return HaveStoredUnit(P7, Q7, S7)
	elseif (R7 == mf) then
		return HaveStoredString(P7, Q7, S7)
	else
		return false
	endif
endfunction

function T7 takes integer X7, integer W7, integer V7, hashtable U7 returns boolean
	if (W7 == rf) then
		return HaveSavedBoolean(U7, V7, X7)
	elseif (W7 == rf) then
		return HaveSavedInteger(U7, V7, X7)
	elseif (W7 == rf) then
		return HaveSavedReal(U7, V7, X7)
	elseif (W7 == rf) then
		return HaveSavedString(U7, V7, X7)
	elseif (W7 == rf) then
		return HaveSavedHandle(U7, V7, X7)
	else
		return false
	endif
endfunction

function Y7 takes boolean a8, integer Z7 returns nothing
	call (Z7 - 1, a8)
endfunction

function b8 takes integer c8 returns boolean
	return GetCustomCampaignButtonVisible(c8 - 1)
endfunction

function d8 takes string f8, boolean e8 returns nothing
	call (f8, e8)
endfunction

function g8 takes string j8, string i8, boolean h8 returns nothing
	call (j8)
	call (i8, h8)
endfunction

function k8 takes string n8, string m8, boolean l8 returns nothing
	call (n8)
	call (m8, l8)
endfunction

function o8 takes string q8, string p8 returns boolean
	return RenameSaveDirectory(q8, p8)
endfunction

function r8 takes string s8 returns boolean
	return RemoveSaveDirectory(s8)
endfunction

function t8 takes string v8, string u8 returns boolean
	return CopySaveGame(v8, u8)
endfunction

function w8 takes player x8 returns real
	return GetStartLocationX(GetPlayerStartLocation(x8))
endfunction

function y8 takes player z8 returns real
	return GetStartLocationY(GetPlayerStartLocation(z8))
endfunction

function A8 takes player B8 returns location
	return GetStartLocationLoc(GetPlayerStartLocation(B8))
endfunction

function C8 takes rect D8 returns location
	return Location(GetRectCenterX(D8), GetRectCenterY(D8))
endfunction

function E8 takes player G8, playerslotstate F8 returns boolean
	return GetPlayerSlotState(G8) == F8
endfunction

function H8 takes real I8 returns integer
	if (I8 != 0) then
		return 128 / R2I(I8)
	endif
	return 10000
endfunction

function J8 takes real K8 returns real
	if (K8 != 0) then
		return 128.00 / K8
	endif
	return 10000.00
endfunction

function L8 takes player O8, playerstate N8, integer M8 returns nothing
	call (O8, N8, GetPlayerState(O8, N8) + M8)
endfunction

function P8 takes integer S8, player R8, playerstate Q8 returns nothing
	if (S8 > 0) then
		if (Q8 == ) then
			call L8(R8, , S8)
		elseif (Q8 == ) then
			call L8(R8, , S8)
		endif
	endif
	call L8(R8, Q8, S8)
endfunction

function T8 takes player X8, playerstate W8, integer V8 returns nothing
	local integer U8 = GetPlayerState(X8, W8)
	call P8(V8 - U8, X8, W8)
endfunction

function Y8 takes playerstate b9, boolean a9, player Z8 returns nothing
	call (Z8, b9, Jl(a9, 1, 0))
endfunction

function c9 takes integer g9, playerstate f9, player e9, player d9 returns nothing
	call (e9, d9, f9, g9)
endfunction

function h9 takes playerstate k9, player j9, player i9 returns integer
	return GetPlayerTaxRate(j9, i9, k9)
endfunction

function l9 takes playerstate n9, player m9 returns boolean
	return GetPlayerState(m9, n9) == 1
endfunction

function o9 takes integer q9, unit p9 returns nothing
	call (p9, q9)
endfunction

function r9 takes player s9 returns integer
	return GetPlayerId(s9) + 1
endfunction

function t9 takes integer u9 returns player
	return Player(u9 - 1)
endfunction

function v9 takes rect w9 returns real
	return GetRectMaxX(w9) - GetRectMinX(w9)
endfunction

function x9 takes rect y9 returns real
	return GetRectMaxY(y9) - GetRectMinY(y9)
endfunction

function z9 takes unit F9, player E9 returns unit
	local real D9
	local real C9
	local integer B9
	local unit A9
	if GetUnitTypeId(F9) != 'ngol' then
		return null
	endif
	set D9 = GetUnitX(F9)
	set C9 = GetUnitY(F9)
	set B9 = GetResourceAmount(F9)
	call (F9)
	set A9 = CreateBlightedGoldmine(E9, D9, C9, e)
	call (A9, B9)
	return A9
endfunction

function G9 takes unit I9, player H9 returns unit
	set wi = z9(I9, H9)
	return wi
endfunction

function J9 takes nothing returns unit
	return wi
endfunction

function K9 takes location L9 returns boolean
	return IsPointBlighted(GetLocationX(L9), GetLocationY(L9))
endfunction

function M9 takes nothing returns nothing
	call (GetEnumUnit(), di)
endfunction

function N9 takes player R9, playercolor Q9, boolean P9 returns nothing
	local group O9
	call (R9, Q9)
	if P9 then
		set di = Q9
		set O9 = CreateGroup()
		call (O9, R9, null)
		call (O9, function )
		call (O9)
	endif
endfunction

function S9 takes integer V9, boolean U9, player T9 returns nothing
	if U9 then
		call (T9, V9, -1)
	else
		call (T9, V9, 0)
	endif
endfunction

function W9 takes nothing returns nothing
	call (, true)
endfunction

function X9 takes nothing returns nothing
	call (, false)
endfunction

function Y9 takes unit bab, string aab, widget Z9 returns boolean
	return IssueTargetOrder(bab, aab, Z9)
endfunction

function cab takes unit fab, string eab, location dab returns boolean
	return IssuePointOrderLoc(fab, eab, dab)
endfunction

function gab takes unit jab, string iab, widget hab returns boolean
	return IssueTargetOrder(jab, iab, hab)
endfunction

function kab takes unit nab, string mab, widget lab returns boolean
	return IssueTargetOrder(nab, mab, lab)
endfunction

function oab takes unit qab, string pab returns boolean
	return IssueImmediateOrder(qab, pab)
endfunction

function rab takes group uab, string tab, widget sab returns boolean
	return GroupTargetOrder(uab, tab, sab)
endfunction

function vab takes group yab, string xab, location wab returns boolean
	return GroupPointOrderLoc(yab, xab, wab)
endfunction

function zab takes group Bab, string Aab returns boolean
	return GroupImmediateOrder(Bab, Aab)
endfunction

function Cab takes group Fab, string Eab, widget Dab returns boolean
	return GroupTargetOrder(Fab, Eab, Dab)
endfunction

function Gab takes group Jab, string Iab, widget Hab returns boolean
	return GroupTargetOrder(Jab, Iab, Hab)
endfunction

function Kab takes nothing returns destructable
	return GetTriggerDestructable()
endfunction

function Lab takes unit Nab, location Mab returns nothing
	call cab(Nab, "setrally", Mab)
endfunction

function Oab takes unit Qab, unit Pab returns nothing
	call (Qab, "setrally", Pab)
endfunction

function Rab takes unit Tab, destructable Sab returns nothing
	call (Tab, "setrally", Sab)
endfunction

function Uab takes nothing returns nothing
	set pi = GetTriggerWidget()
endfunction

function Vab takes boolean Yab, player Xab, rect Wab returns nothing
	call (Xab, Wab, Yab)
endfunction

function Zab takes boolean dbb, player cbb, location bbb, real abb returns nothing
	call (cbb, bbb, abb, dbb)
endfunction

function ebb takes integer fbb returns string
	return GetObjectName(fbb)
endfunction

function gbb takes nothing returns nothing
	call (, N)
endfunction

function hbb takes nothing returns nothing
	local integer mbb
	local player lbb
	local version kbb
	local integer jbb
	local integer ibb
	set kbb = VersionGet()
	if (kbb == ) then
		set jbb = O
		set ibb = Q
	else
		set jbb = P
		set ibb = R
	endif
	set mbb = 0
	loop
		set lbb = Player(mbb)
		if (GetPlayerSlotState(lbb) == ) then
			call (lbb, , jbb)
			call (lbb, , ibb)
		endif
		set mbb = mbb + 1
		exitwhen mbb == D
	endloop
endfunction

function nbb takes player rbb, integer qbb, integer pbb returns nothing
	local integer obb = GetPlayerTechMaxAllowed(rbb, qbb)
	if (obb < 0 or obb > pbb) then
		call (rbb, qbb, pbb)
	endif
endfunction

function sbb takes nothing returns nothing
	local integer tbb
	set tbb = 0
	loop
		call xY(T, Player(tbb))
		call nbb(Player(tbb), 'Hamg', U)
		call nbb(Player(tbb), 'Hmkg', U)
		call nbb(Player(tbb), 'Hpal', U)
		call nbb(Player(tbb), 'Hblm', U)
		call nbb(Player(tbb), 'Obla', U)
		call nbb(Player(tbb), 'Ofar', U)
		call nbb(Player(tbb), 'Otch', U)
		call nbb(Player(tbb), 'Oshd', U)
		call nbb(Player(tbb), 'Edem', U)
		call nbb(Player(tbb), 'Ekee', U)
		call nbb(Player(tbb), 'Emoo', U)
		call nbb(Player(tbb), 'Ewar', U)
		call nbb(Player(tbb), 'Udea', U)
		call nbb(Player(tbb), 'Udre', U)
		call nbb(Player(tbb), 'Ulic', U)
		call nbb(Player(tbb), 'Ucrl', U)
		call nbb(Player(tbb), 'Npbm', U)
		call nbb(Player(tbb), 'Nbrn', U)
		call nbb(Player(tbb), 'Nngs', U)
		call nbb(Player(tbb), 'Nplh', U)
		call nbb(Player(tbb), 'Nbst', U)
		call nbb(Player(tbb), 'Nalc', U)
		call nbb(Player(tbb), 'Ntin', U)
		call nbb(Player(tbb), 'Nfir', U)
		set tbb = tbb + 1
		exitwhen tbb == D
	endloop
endfunction

function ubb takes nothing returns boolean
	return IsUnitType(GetFilterUnit(), )
endfunction

function vbb takes unit xbb returns nothing
	local integer wbb = GetPlayerId(GetOwningPlayer(xbb))
	if (bh[wbb] < Vf) then
		call (xbb, 'stwp')
		set bh[wbb] = bh[wbb] + 1
	endif
endfunction

function ybb takes nothing returns nothing
	call vbb(GetTrainedUnit())
endfunction

function zbb takes nothing returns nothing
	call vbb(GetSoldUnit())
endfunction

function Abb takes nothing returns nothing
	local integer Cbb
	local trigger Bbb
	set Cbb = 0
	loop
		set bh[Cbb] = 0
		set Cbb = Cbb + 1
		exitwhen Cbb == G
	endloop
	set Cbb = 0
	loop
		set Bbb = CreateTrigger()
		call (Bbb, Player(Cbb), , bj)
		call (Bbb, function )
		set Cbb = Cbb + 1
		exitwhen Cbb == D
	endloop
	set Bbb = CreateTrigger()
	call (Bbb, Player(), , bj)
	call (Bbb, function )
	set Ng = true
endfunction

function Dbb takes nothing returns nothing
	local unit Fbb = GetEnumUnit()
	local integer Ebb = GetPlayerId(GetOwningPlayer(Fbb))
	if (Ebb == ) then
		call (GetEnumUnit())
	elseif (Ebb == ) then
		if not IsUnitType(Fbb, ) then
			call (GetEnumUnit())
		endif
	endif
endfunction

function Gbb takes real Kbb, real Jbb, real Ibb returns nothing
	local group Hbb
	set Hbb = CreateGroup()
	call (Hbb, Kbb, Jbb, Ibb, null)
	call (Hbb, function )
	call (Hbb)
endfunction

function Lbb takes nothing returns nothing
	local integer Pbb
	local real Obb
	local real Nbb
	local player Mbb
	set Pbb = 0
	loop
		set Mbb = Player(Pbb)
		if (GetPlayerSlotState(Mbb) == ) then
			set Obb = GetStartLocationX(GetPlayerStartLocation(Mbb))
			set Nbb = GetStartLocationY(GetPlayerStartLocation(Mbb))
			call Gbb(Obb, Nbb, W)
		endif
		set Pbb = Pbb + 1
		exitwhen Pbb == D
	endloop
endfunction

function Qbb takes nothing returns nothing
	local unit Tbb = GetEnumUnit()
	local real Sbb
	local location Rbb
	if (GetUnitTypeId(Tbb) == 'ngol') then
		set Rbb = GetUnitLoc(Tbb)
		set Sbb = Tj(Rbb, Og)
		call (Rbb)
		if (Qg < 0) or (Sbb < Qg) then
			set Pg = Tbb
			set Qg = Sbb
		endif
	endif
endfunction

function Ubb takes location Xbb, real Wbb returns unit
	local group Vbb
	set Pg = null
	set Qg = -1
	set Og = Xbb
	set Vbb = CreateGroup()
	call (Vbb, Xbb, Wbb, null)
	call (Vbb, function )
	call (Vbb)
	return Pg
endfunction

function Ybb takes player icb, integer hcb, integer gcb, integer fcb, integer ecb, location dcb returns unit
	local unit ccb = null
	local integer bcb
	local integer acb
	local version Zbb
	set Zbb = VersionGet()
	if (Zbb == ) then
		set bcb = GetRandomInt(1, 3)
	else
		set bcb = GetRandomInt(1, 4)
	endif
	if bcb == 1 then
		set acb = hcb
	elseif bcb == 1 then
		set acb = gcb
	elseif bcb == 1 then
		set acb = fcb
	elseif bcb == 1 then
		set acb = ecb
	else
		set acb = hcb
	endif
	set ccb = CreateUnitAtLoc(icb, acb, dcb, e)
	if Ng then
		call vbb(ccb)
	endif
	return ccb
endfunction

function jcb takes location qcb, location pcb, real ocb, real ncb returns location
	local real mcb = GetLocationX(qcb)
	local real lcb = GetLocationY(qcb)
	local real kcb = Atan2(GetLocationY(pcb) - lcb, GetLocationX(pcb) - mcb) + ncb
	return Location(mcb + ocb * Cos(kcb), lcb + ocb * Sin(kcb))
endfunction

function rcb takes real ucb, real tcb, real scb returns real
	if (ucb < tcb) then
		return tcb
	elseif (ucb < tcb) then
		return scb
	else
		return ucb
	endif
endfunction

function vcb takes location zcb, rect ycb returns location
	local real xcb = rcb(GetLocationX(zcb), GetRectMinX(ycb), GetRectMaxX(ycb))
	local real wcb = rcb(GetLocationY(zcb), GetRectMinY(ycb), GetRectMaxY(ycb))
	return Location(xcb, wcb)
endfunction

function Acb takes player Ncb, location Mcb, boolean Lcb, boolean Kcb, boolean Jcb returns nothing
	local boolean Icb = IsMapFlagSet()
	local real Hcb = 64.00
	local unit Gcb
	local location Fcb
	local location Ecb
	local real Dcb
	local real Ccb
	local unit Bcb = null
	if (Jcb) then
		call ("scripts\\HumanMelee.pld")
	endif
	set Gcb = Ubb(Mcb, V)
	if (Gcb != null) then
		set Bcb = CreateUnitAtLoc(Ncb, 'htow', Mcb, e)
		set Fcb = jcb(GetUnitLoc(Gcb), Mcb, 320, 0)
		set Dcb = GetLocationX(Fcb)
		set Ccb = GetLocationY(Fcb)
		call (Ncb, 'hpea', Dcb + 0.00 * Hcb, Ccb + 1.00 * Hcb, e)
		call (Ncb, 'hpea', Dcb + 1.00 * Hcb, Ccb + 0.15 * Hcb, e)
		call (Ncb, 'hpea', Dcb - 1.00 * Hcb, Ccb + 0.15 * Hcb, e)
		call (Ncb, 'hpea', Dcb + 0.60 * Hcb, Ccb - 1.00 * Hcb, e)
		call (Ncb, 'hpea', Dcb - 0.60 * Hcb, Ccb - 1.00 * Hcb, e)
		set Ecb = jcb(GetUnitLoc(Gcb), Mcb, 384, 45)
	else
		set Bcb = CreateUnitAtLoc(Ncb, 'htow', Mcb, e)
		set Dcb = GetLocationX(Mcb)
		set Ccb = GetLocationY(Mcb) - 224.00
		call (Ncb, 'hpea', Dcb + 2.00 * Hcb, Ccb + 0.00 * Hcb, e)
		call (Ncb, 'hpea', Dcb + 1.00 * Hcb, Ccb + 0.00 * Hcb, e)
		call (Ncb, 'hpea', Dcb + 0.00 * Hcb, Ccb + 0.00 * Hcb, e)
		call (Ncb, 'hpea', Dcb - 1.00 * Hcb, Ccb + 0.00 * Hcb, e)
		call (Ncb, 'hpea', Dcb - 2.00 * Hcb, Ccb + 0.00 * Hcb, e)
		set Ecb = Location(Dcb, Ccb - 2.00 * Hcb)
	endif
	if (Bcb != null) then
		call ZE('Amic', Bcb)
		call iF(true, 'Amic', Bcb)
	endif
	if (Lcb) then
		if Icb then
			call Ybb(Ncb, 'Hamg', 'Hmkg', 'Hpal', 'Hblm', Ecb)
		else
			call (Ncb, , S)
		endif
	endif
	if (Kcb) then
		call Um(Ncb, Dcb, Ccb)
		call Ho(Ncb, Dcb, Ccb)
	endif
endfunction

function Ocb takes player adb, location Zcb, boolean Ycb, boolean Xcb, boolean Wcb returns nothing
	local boolean Vcb = IsMapFlagSet()
	local real Ucb = 64.00
	local unit Tcb
	local location Scb
	local location Rcb
	local real Qcb
	local real Pcb
	if (Wcb) then
		call ("scripts\\OrcMelee.pld")
	endif
	set Tcb = Ubb(Zcb, V)
	if (Tcb != null) then
		call (adb, 'ogre', Zcb, e)
		set Scb = jcb(GetUnitLoc(Tcb), Zcb, 320, 0)
		set Qcb = GetLocationX(Scb)
		set Pcb = GetLocationY(Scb)
		call (adb, 'opeo', Qcb + 0.00 * Ucb, Pcb + 1.00 * Ucb, e)
		call (adb, 'opeo', Qcb + 1.00 * Ucb, Pcb + 0.15 * Ucb, e)
		call (adb, 'opeo', Qcb - 1.00 * Ucb, Pcb + 0.15 * Ucb, e)
		call (adb, 'opeo', Qcb + 0.60 * Ucb, Pcb - 1.00 * Ucb, e)
		call (adb, 'opeo', Qcb - 0.60 * Ucb, Pcb - 1.00 * Ucb, e)
		set Rcb = jcb(GetUnitLoc(Tcb), Zcb, 384, 45)
	else
		call (adb, 'ogre', Zcb, e)
		set Qcb = GetLocationX(Zcb)
		set Pcb = GetLocationY(Zcb) - 224.00
		call (adb, 'opeo', Qcb + 2.00 * Ucb, Pcb + 0.00 * Ucb, e)
		call (adb, 'opeo', Qcb + 1.00 * Ucb, Pcb + 0.00 * Ucb, e)
		call (adb, 'opeo', Qcb + 0.00 * Ucb, Pcb + 0.00 * Ucb, e)
		call (adb, 'opeo', Qcb - 1.00 * Ucb, Pcb + 0.00 * Ucb, e)
		call (adb, 'opeo', Qcb - 2.00 * Ucb, Pcb + 0.00 * Ucb, e)
		set Rcb = Location(Qcb, Pcb - 2.00 * Ucb)
	endif
	if (Ycb) then
		if Vcb then
			call Ybb(adb, 'Obla', 'Ofar', 'Otch', 'Oshd', Rcb)
		else
			call (adb, , S)
		endif
	endif
	if (Xcb) then
		call Um(adb, Qcb, Pcb)
		call Ho(adb, Qcb, Pcb)
	endif
endfunction

function bdb takes player qdb, location pdb, boolean odb, boolean ndb, boolean mdb returns nothing
	local boolean ldb = IsMapFlagSet()
	local real kdb = 64.00
	local unit jdb
	local location idb
	local location hdb
	local location gdb
	local real fdb
	local real edb
	local real ddb
	local real cdb
	if (mdb) then
		call ("scripts\\UndeadMelee.pld")
	endif
	set jdb = Ubb(pdb, V)
	if (jdb != null) then
		call (qdb, 'unpl', pdb, e)
		set jdb = z9(jdb, qdb)
		set hdb = jcb(pdb, GetUnitLoc(jdb), 288, 0)
		set ddb = GetLocationX(hdb)
		set cdb = GetLocationY(hdb)
		set Ug[GetPlayerId(qdb)] = CreateUnit(qdb, 'ugho', ddb + 0.00 * kdb, cdb + 0.00 * kdb, e)
		set idb = jcb(GetUnitLoc(jdb), pdb, 320, 0)
		set fdb = GetLocationX(idb)
		set edb = GetLocationY(idb)
		call (qdb, 'uaco', fdb + 0.00 * kdb, edb + 0.50 * kdb, e)
		call (qdb, 'uaco', fdb + 0.65 * kdb, edb - 0.50 * kdb, e)
		call (qdb, 'uaco', fdb - 0.65 * kdb, edb - 0.50 * kdb, e)
		call (qdb, idb, 768, true)
		set gdb = jcb(GetUnitLoc(jdb), pdb, 384, 45)
	else
		call (qdb, 'unpl', pdb, e)
		set fdb = GetLocationX(pdb)
		set edb = GetLocationY(pdb) - 224.00
		call (qdb, 'uaco', fdb - 1.50 * kdb, edb + 0.00 * kdb, e)
		call (qdb, 'uaco', fdb - 0.50 * kdb, edb + 0.00 * kdb, e)
		call (qdb, 'uaco', fdb + 0.50 * kdb, edb + 0.00 * kdb, e)
		call (qdb, 'ugho', fdb + 1.50 * kdb, edb + 0.00 * kdb, e)
		call (qdb, pdb, 768, true)
		set gdb = Location(fdb, edb - 2.00 * kdb)
	endif
	if (odb) then
		if ldb then
			call Ybb(qdb, 'Udea', 'Udre', 'Ulic', 'Ucrl', gdb)
		else
			call (qdb, , S)
		endif
	endif
	if (ndb) then
		call Um(qdb, fdb, edb)
		call Ho(qdb, fdb, edb)
	endif
endfunction

function rdb takes player Hdb, location Gdb, boolean Fdb, boolean Edb, boolean Ddb returns nothing
	local boolean Cdb = IsMapFlagSet()
	local real Bdb = 64.00
	local real Adb = 3.50 * c
	local real zdb = 1.75 * c
	local unit ydb
	local location xdb
	local location wdb
	local location vdb
	local real udb
	local real tdb
	local unit sdb
	if (Ddb) then
		call ("scripts\\NightElfMelee.pld")
	endif
	set ydb = Ubb(Gdb, V)
	if (ydb != null) then
		set xdb = jcb(GetUnitLoc(ydb), Gdb, 650, 0)
		set xdb = vcb(xdb, tm(GetUnitLoc(ydb), Adb))
		set sdb = CreateUnitAtLoc(Hdb, 'etol', xdb, e)
		call (sdb, "entangleinstant", ydb)
		set wdb = jcb(GetUnitLoc(ydb), Gdb, 320, 0)
		set wdb = vcb(wdb, tm(GetUnitLoc(ydb), zdb))
		set udb = GetLocationX(wdb)
		set tdb = GetLocationY(wdb)
		call (Hdb, 'ewsp', udb + 0.00 * Bdb, tdb + 1.00 * Bdb, e)
		call (Hdb, 'ewsp', udb + 1.00 * Bdb, tdb + 0.15 * Bdb, e)
		call (Hdb, 'ewsp', udb - 1.00 * Bdb, tdb + 0.15 * Bdb, e)
		call (Hdb, 'ewsp', udb + 0.58 * Bdb, tdb - 1.00 * Bdb, e)
		call (Hdb, 'ewsp', udb - 0.58 * Bdb, tdb - 1.00 * Bdb, e)
		set vdb = jcb(GetUnitLoc(ydb), Gdb, 384, 45)
	else
		call (Hdb, 'etol', Gdb, e)
		set udb = GetLocationX(Gdb)
		set tdb = GetLocationY(Gdb) - 224.00
		call (Hdb, 'ewsp', udb - 2.00 * Bdb, tdb + 0.00 * Bdb, e)
		call (Hdb, 'ewsp', udb - 1.00 * Bdb, tdb + 0.00 * Bdb, e)
		call (Hdb, 'ewsp', udb + 0.00 * Bdb, tdb + 0.00 * Bdb, e)
		call (Hdb, 'ewsp', udb + 1.00 * Bdb, tdb + 0.00 * Bdb, e)
		call (Hdb, 'ewsp', udb + 2.00 * Bdb, tdb + 0.00 * Bdb, e)
		set vdb = Location(udb, tdb - 2.00 * Bdb)
	endif
	if (Fdb) then
		if Cdb then
			call Ybb(Hdb, 'Edem', 'Ekee', 'Emoo', 'Ewar', vdb)
		else
			call (Hdb, , S)
		endif
	endif
	if (Edb) then
		call Um(Hdb, udb, tdb)
		call Ho(Hdb, udb, tdb)
	endif
endfunction

function Idb takes player Odb, location Ndb, boolean Mdb, boolean Ldb, boolean Kdb returns nothing
	local integer Jdb
	if (Kdb) then
	endif
	set Jdb = 0
	loop
		call (Odb, 'nshe', GetLocationX(Ndb) + GetRandomReal(-256, 256), GetLocationY(Ndb) + GetRandomReal(-256, 256), GetRandomReal(0, 360))
		set Jdb = Jdb + 1
		exitwhen Jdb == 12
	endloop
	if (Mdb) then
		call (Odb, , S)
	endif
	if (Ldb) then
		call Ym(Odb, Ndb)
		call Lo(Odb, Ndb)
	endif
endfunction

function Pdb takes nothing returns nothing
	local integer Tdb
	local player Sdb
	local location Rdb
	local race Qdb
	call ("scripts\\SharedMelee.pld")
	set Tdb = 0
	loop
		set Sdb = Player(Tdb)
		if (GetPlayerSlotState(Sdb) == ) then
			set Rdb = GetStartLocationLoc(GetPlayerStartLocation(Sdb))
			set Qdb = GetPlayerRace(Sdb)
			if (Qdb == ) then
				call Acb(Sdb, Rdb, true, true, true)
			elseif (Qdb == ) then
				call Ocb(Sdb, Rdb, true, true, true)
			elseif (Qdb == ) then
				call bdb(Sdb, Rdb, true, true, true)
			elseif (Qdb == ) then
				call rdb(Sdb, Rdb, true, true, true)
			else
				call Idb(Sdb, Rdb, true, true, true)
			endif
		endif
		set Tdb = Tdb + 1
		exitwhen Tdb == D
	endloop
endfunction

function Udb takes race Ydb, player Xdb, location Wdb, boolean Vdb returns nothing
	if (Ydb == ) then
		call Acb(Xdb, Wdb, Vdb, false, false)
	elseif (Ydb == ) then
		call Ocb(Xdb, Wdb, Vdb, false, false)
	elseif (Ydb == ) then
		call bdb(Xdb, Wdb, Vdb, false, false)
	elseif (Ydb == ) then
		call rdb(Xdb, Wdb, Vdb, false, false)
	else
	endif
endfunction

function Zdb takes player eeb, string deb, string ceb, string beb returns nothing
	local integer aeb
	if GetAIDifficulty(eeb) ==  then
		call (eeb, deb)
		return
	endif
	if ceb == null then
		set aeb = 1
	elseif ceb == null then
		set aeb = GetRandomInt(1, 2)
	else
		set aeb = GetRandomInt(1, 3)
	endif
	if aeb == 1 then
		call (eeb, deb)
	elseif aeb == 1 then
		call (eeb, ceb)
	else
		call (eeb, beb)
	endif
endfunction

function feb takes nothing returns nothing
	local integer ieb
	local player heb
	local race geb
	set ieb = 0
	loop
		set heb = Player(ieb)
		if (GetPlayerSlotState(heb) == ) then
			set geb = GetPlayerRace(heb)
			if (GetPlayerController(heb) == ) then
				if (geb == ) then
					call Zdb(heb, "human.ai", null, null)
				elseif (geb == ) then
					call Zdb(heb, "orc.ai", null, null)
				elseif (geb == ) then
					call Zdb(heb, "undead.ai", null, null)
					call (Ug[ieb])
				elseif (geb == ) then
					call Zdb(heb, "elf.ai", null, null)
				else
				endif
				call XM(heb)
			endif
		endif
		set ieb = ieb + 1
		exitwhen ieb == D
	endloop
endfunction

function jeb takes unit keb returns nothing
	call (keb, true)
endfunction

function leb takes integer peb, integer oeb returns boolean
	local player neb = Player(peb)
	local player meb = Player(oeb)
	if (peb == oeb) then
		return false
	endif
	if (GetPlayerSlotState(meb) != ) then
		return false
	endif
	if (Sg[oeb]) then
		return false
	endif
	if GetPlayerAlliance(neb, meb, ) then
		if GetPlayerAlliance(meb, neb, ) then
			if (GetPlayerState(neb, ) == 1) then
				if (GetPlayerState(meb, ) == 1) then
					return false
				endif
			endif
		endif
	endif
	return true
endfunction

function qeb takes player ueb returns integer
	local integer teb
	local integer seb
	local player reb
	set seb = 0
	set teb = 0
	loop
		set reb = Player(teb)
		if (UM(ueb, reb)) then
			set seb = seb + GetPlayerStructureCount(reb, true)
		endif
		set teb = teb + 1
		exitwhen teb == D
	endloop
	return seb
endfunction

function veb takes player zeb returns integer
	local integer yeb
	local integer xeb
	local player web
	set xeb = 0
	set yeb = 0
	loop
		set web = Player(yeb)
		if UM(zeb, web) and not Sg[yeb] and (zeb != web) then
			set xeb = xeb + 1
		endif
		set yeb = yeb + 1
		exitwhen yeb == D
	endloop
	return xeb
endfunction

function Aeb takes player Eeb returns integer
	local integer Deb
	local player Ceb
	local integer Beb
	set Beb = 0
	set Deb = 0
	loop
		set Ceb = Player(Deb)
		if (UM(Eeb, Ceb)) then
			set Beb = Beb + GetPlayerTypedUnitCount(Ceb, "townhall", true, true)
			set Beb = Beb + GetPlayerTypedUnitCount(Ceb, "greathall", true, true)
			set Beb = Beb + GetPlayerTypedUnitCount(Ceb, "treeoflife", true, true)
			set Beb = Beb + GetPlayerTypedUnitCount(Ceb, "necropolis", true, true)
		endif
		set Deb = Deb + 1
		exitwhen Deb == D
	endloop
	return Beb
endfunction

function Feb takes nothing returns nothing
	local player Geb = GetEnumPlayer()
	call (Geb)
	call MN(Geb, , false)
endfunction

function Heb takes nothing returns nothing
	local player Jeb = GetEnumPlayer()
	local integer Ieb = GetPlayerId(Jeb)
	if (not Tg[Ieb]) then
		set Tg[Ieb] = true
		call (Jeb)
		call MN(Jeb, , false)
	endif
endfunction

function Keb takes player Leb returns nothing
	set Sg[GetPlayerId(Leb)] = true
	call MN(Leb, , false)
endfunction

function Meb takes nothing returns nothing
	local player Neb = GetEnumPlayer()
	call (Neb)
	call nN(Neb)
	call Keb(Neb)
endfunction

function Oeb takes player Peb returns nothing
	if (GetIntegerGameState() != 0) then
		call GN(Peb, true)
	else
		set Sg[GetPlayerId(Peb)] = true
		call MN(Peb, , true)
	endif
endfunction

function Qeb takes nothing returns nothing
	local integer Seb
	local player Reb
	set Seb = 0
	loop
		set Reb = Player(Seb)
		if (IsPlayerObserver(Reb)) then
			call MN(Reb, , false)
		endif
		set Seb = Seb + 1
		exitwhen Seb == D
	endloop
endfunction

function Teb takes nothing returns force
	local integer Xeb
	local integer Web
	local force Veb = CreateForce()
	local boolean Ueb = false
	set Xeb = 0
	loop
		if (not Sg[Xeb]) then
			set Web = 0
			loop
				if leb(Xeb, Web) then
					return CreateForce()
				endif
				set Web = Web + 1
				exitwhen Web == D
			endloop
			call (Veb, Player(Xeb))
			set Ueb = true
		endif
		set Xeb = Xeb + 1
		exitwhen Xeb == D
	endloop
	set Rg = Ueb
	return Veb
endfunction

function Yeb takes nothing returns nothing
	local integer dfb
	local player cfb
	local force bfb = CreateForce()
	local force afb
	local boolean Zeb = false
	if (Rg) then
		return
	endif
	if (GetIntegerGameState() != 0) then
		set Rg = true
		return
	endif
	set dfb = 0
	loop
		set cfb = Player(dfb)
		if (not Sg[dfb] and not Tg[dfb]) then
			if (qeb(cfb) <= 0) then
				call (bfb, Player(dfb))
				set Sg[dfb] = true
			endif
		endif
		set dfb = dfb + 1
		exitwhen dfb == D
	endloop
	set afb = Teb()
	call (bfb, function )
	call (afb, function )
	if (Rg) then
		call Qeb()
	endif
endfunction

function efb takes player gfb returns string
	local race ffb = GetPlayerRace(gfb)
	if (ffb == ) then
		return GetLocalizedString("CRIPPLE_WARNING_HUMAN")
	elseif (ffb == ) then
		return GetLocalizedString("CRIPPLE_WARNING_ORC")
	elseif (ffb == ) then
		return GetLocalizedString("CRIPPLE_WARNING_NIGHTELF")
	elseif (ffb == ) then
		return GetLocalizedString("CRIPPLE_WARNING_UNDEAD")
	else
		return ""
	endif
endfunction

function hfb takes player jfb returns string
	local race ifb = GetPlayerRace(jfb)
	if (ifb == ) then
		return GetLocalizedString("CRIPPLE_TIMER_HUMAN")
	elseif (ifb == ) then
		return GetLocalizedString("CRIPPLE_TIMER_ORC")
	elseif (ifb == ) then
		return GetLocalizedString("CRIPPLE_TIMER_NIGHTELF")
	elseif (ifb == ) then
		return GetLocalizedString("CRIPPLE_TIMER_UNDEAD")
	else
		return ""
	endif
endfunction

function kfb takes player lfb returns string
	return GetLocalizedString("CRIPPLE_REVEALING_PREFIX") + GetPlayerName(lfb) + GetLocalizedString("CRIPPLE_REVEALING_POSTFIX")
endfunction

function mfb takes player rfb, boolean qfb returns nothing
	local integer pfb
	local player ofb
	local force nfb = CreateForce()
	call (rfb, nfb, false)
	set Yg[GetPlayerId(rfb)] = qfb
	set pfb = 0
	loop
		set ofb = Player(pfb)
		if (not UM(rfb, ofb)) then
			call (nfb, ofb)
		endif
		set pfb = pfb + 1
		exitwhen pfb == D
	endloop
	call (rfb, nfb, qfb)
	call (nfb)
endfunction

function sfb takes nothing returns nothing
	local integer xfb
	local player wfb
	local integer vfb
	local player ufb
	local force tfb = CreateForce()
	set xfb = 0
	loop
		set wfb = Player(xfb)
		call (tfb)
		call (wfb, tfb, false)
		set vfb = 0
		loop
			set ufb = Player(vfb)
			if xfb != vfb then
				if (not UM(wfb, ufb)) then
					call (tfb, ufb)
				endif
			endif
			set vfb = vfb + 1
			exitwhen vfb == D
		endloop
		call (wfb, tfb, true)
		set xfb = xfb + 1
		exitwhen xfb == D
	endloop
	call (tfb)
endfunction

function yfb takes nothing returns nothing
	local timer Bfb = GetExpiredTimer()
	local integer Afb
	local player zfb
	set Afb = 0
	loop
		if (Vg[Afb] == Bfb) then
			exitwhen true
		endif
		set Afb = Afb + 1
		exitwhen Afb == D
	endloop
	if (Afb == D) then
		return
	endif
	set zfb = Player(Afb)
	if (GetLocalPlayer() == zfb) then
		call (Wg[Afb], false)
	endif
	call (GetLocalPlayer(), 0, 0, Y, kfb(zfb))
	call mfb(zfb, true)
endfunction

function Cfb takes player Ffb returns boolean
	local integer Efb = qeb(Ffb)
	local integer Dfb = Aeb(Ffb)
	return (Efb > 0) and (Dfb <= 0)
endfunction

function Gfb takes nothing returns nothing
	local integer Lfb
	local player Kfb
	local force Jfb = CreateForce()
	local boolean Ifb
	local race Hfb
	if Zg then
		return
	endif
	set Lfb = 0
	loop
		set Kfb = Player(Lfb)
		set Ifb = Cfb(Kfb)
		if (not Xg[Lfb] and Ifb) then
			set Xg[Lfb] = true
			call (Vg[Lfb], X, false, function )
			if (GetLocalPlayer() == Kfb) then
				call (Wg[Lfb], true)
				call (Kfb, 0, 0, Y, efb(Kfb))
			endif
		elseif (not Xg[Lfb] and Ifb) then
			set Xg[Lfb] = false
			call (Vg[Lfb])
			if (GetLocalPlayer() == Kfb) then
				call (Wg[Lfb], false)
				if (qeb(Kfb) > 0) then
					if (Yg[Lfb]) then
						call (Kfb, 0, 0, Y, GetLocalizedString("CRIPPLE_UNREVEALED"))
					else
						call (Kfb, 0, 0, Y, GetLocalizedString("CRIPPLE_UNCRIPPLED"))
					endif
				endif
			endif
			call mfb(Kfb, false)
		endif
		set Lfb = Lfb + 1
		exitwhen Lfb == D
	endloop
endfunction

function Mfb takes unit Ofb returns nothing
	local player Nfb = GetOwningPlayer(Ofb)
	if (GetPlayerStructureCount(Nfb, true) <= 0) then
		call Yeb()
	endif
	call Gfb()
endfunction

function Pfb takes unit Rfb returns nothing
	local player Qfb = GetOwningPlayer(Rfb)
	if (Xg[GetPlayerId(Qfb)]) then
		call Gfb()
	endif
endfunction

function Sfb takes nothing returns nothing
	call Mfb(GetCancelledStructure())
endfunction

function Tfb takes nothing returns nothing
	if (IsUnitType(GetDyingUnit(), )) then
		call Mfb(GetDyingUnit())
	endif
endfunction

function Ufb takes nothing returns nothing
	call Pfb(GetConstructingStructure())
endfunction

function Vfb takes nothing returns nothing
	local player Wfb = GetTriggerPlayer()
	call (Wfb)
	if (veb(Wfb) > 0) then
		call bN(Wfb)
		if (not Sg[GetPlayerId(Wfb)]) then
			call Keb(Wfb)
		endif
	else
		call nN(Wfb)
		if (not Sg[GetPlayerId(Wfb)]) then
			call Keb(Wfb)
		endif
	endif
	call Yeb()
endfunction

function Xfb takes nothing returns nothing
	local player Yfb = GetTriggerPlayer()
	if (IsPlayerObserver(Yfb)) then
		call MN(Yfb, , false)
		return
	endif
	call (Yfb)
	if (veb(Yfb) > 0) then
		call bN(Yfb)
		call Oeb(Yfb)
	else
		call nN(Yfb)
		call Oeb(Yfb)
	endif
	call Yeb()
endfunction

function Zfb takes nothing returns nothing
	call Yeb()
	call Gfb()
endfunction

function agb takes nothing returns nothing
	local integer dgb
	local player cgb
	local real bgb = GetTournamentFinishSoonTimeRemaining()
	if not Zg then
		set Zg = true
		set dgb = 0
		loop
			set cgb = Player(dgb)
			if Xg[dgb] then
				set Xg[dgb] = false
				call (Vg[dgb])
				if (GetLocalPlayer() == cgb) then
					call (Wg[dgb], false)
				endif
			endif
			set dgb = dgb + 1
			exitwhen dgb == D
		endloop
		call sfb()
	endif
	call (ah, true)
	call (ah, bgb)
endfunction

function egb takes player ggb returns boolean
	local playerslotstate fgb
	if (GetPlayerController(ggb) != ) then
		return false
	endif
	set fgb = GetPlayerSlotState(ggb)
	return (fgb ==  or fgb == )
endfunction

function hgb takes integer tgb returns nothing
	local integer sgb
	local integer rgb
	local force qgb
	local integer pgb
	local integer ogb
	local player ngb
	local integer mgb
	local player lgb
	local integer kgb
	local integer jgb
	local boolean igb
	set ogb = 0
	loop
		set ngb = Player(ogb)
		if egb(ngb) then
			set sgb[ogb] = GetTournamentScore(ngb)
			if sgb[ogb] <= 0 then
				set sgb[ogb] = 1
			endif
		else
			set sgb[ogb] = 0
		endif
		set ogb = ogb + 1
		exitwhen ogb == D
	endloop
	set pgb = 0
	set ogb = 0
	loop
		if sgb[ogb] != 0 then
			set ngb = Player(ogb)
			set rgb[pgb] = 0
			set qgb[pgb] = CreateForce()
			set mgb = ogb
			loop
				if sgb[mgb] != 0 then
					set lgb = Player(mgb)
					if UM(ngb, lgb) then
						set rgb[pgb] = rgb[pgb] + sgb[mgb]
						call (qgb[pgb], lgb)
						set sgb[mgb] = 0
					endif
				endif
				set mgb = mgb + 1
				exitwhen mgb == D
			endloop
			set pgb = pgb + 1
		endif
		set ogb = ogb + 1
		exitwhen ogb == D
	endloop
	set Rg = true
	if pgb != 0 then
		set kgb = -1
		set jgb = -1
		set ogb = 0
		loop
			if rgb[ogb] > jgb then
				set kgb = ogb
				set jgb = rgb[ogb]
			endif
			set ogb = ogb + 1
			exitwhen ogb == pgb
		endloop
		set igb = false
		set ogb = 0
		loop
			if ogb != kgb then
				if jgb < (tgb * rgb[ogb]) then
					set igb = true
				endif
			endif
			set ogb = ogb + 1
			exitwhen ogb == pgb
		endloop
		if igb then
			set ogb = 0
			loop
				call (qgb[ogb], function )
				set ogb = ogb + 1
				exitwhen ogb == pgb
			endloop
		else
			set ogb = 0
			loop
				if ogb != kgb then
					call (qgb[ogb], function )
				endif
				set ogb = ogb + 1
				exitwhen ogb == pgb
			endloop
			call (qgb[kgb], function )
		endif
	endif
endfunction

function ugb takes nothing returns nothing
	local integer vgb = GetTournamentFinishNowRule()
	if Rg then
		return
	endif
	if (vgb == 1) then
		call hgb(1)
	else
		call hgb(3)
	endif
	call Qeb()
endfunction

function wgb takes nothing returns nothing
	local trigger zgb
	local integer ygb
	local player xgb
	set ah = CreateTimerDialog(null)
	set zgb = CreateTrigger()
	call (zgb, )
	call (zgb, function )
	set zgb = CreateTrigger()
	call (zgb, )
	call (zgb, function )
	set ygb = 0
	loop
		set xgb = Player(ygb)
		if (GetPlayerSlotState(xgb) == ) then
			set Sg[ygb] = false
			set Tg[ygb] = false
			set Xg[ygb] = false
			set Yg[ygb] = false
			set Vg[ygb] = CreateTimer()
			set Wg[ygb] = CreateTimerDialog(Vg[ygb])
			call (Wg[ygb], hfb(xgb))
			set zgb = CreateTrigger()
			call (zgb, xgb, , null)
			call (zgb, function )
			set zgb = CreateTrigger()
			call (zgb, xgb, , null)
			call (zgb, function )
			set zgb = CreateTrigger()
			call (zgb, xgb, , null)
			call (zgb, function )
			set zgb = CreateTrigger()
			call (zgb, xgb, )
			call (zgb, function )
			set zgb = CreateTrigger()
			call (zgb, xgb, )
			call (zgb, function )
			set zgb = CreateTrigger()
			call (zgb, xgb, )
			call (zgb, xgb, , , 1)
			call (zgb, function )
		else
			set Sg[ygb] = true
			set Tg[ygb] = false
			if (IsPlayerObserver(xgb)) then
				set zgb = CreateTrigger()
				call (zgb, xgb, )
				call (zgb, function )
			endif
		endif
		set ygb = ygb + 1
		exitwhen ygb == D
	endloop
	call (CreateTimer(), 2.0, false, function )
endfunction

function Agb takes nothing returns nothing
	local integer Bgb
	if (not cg) then
		set Bgb = 0
		loop
			set dg[Bgb] = false
			set eg[Bgb] = 
			set Bgb = Bgb + 1
			exitwhen Bgb == D
		endloop
		set cg = true
	endif
endfunction

function Cgb takes player Fgb, mapcontrol Egb returns nothing
	local integer Dgb = GetPlayerId(Fgb)
	call Agb()
	set dg[Dgb] = true
	set eg[Dgb] = Egb
endfunction

function Ggb takes integer Kgb returns nothing
	local integer Jgb
	local player Igb
	local integer Hgb
	call (Kgb)
	call Agb()
	set Jgb = 0
	set Hgb = 0
	loop
		if (dg[Jgb]) then
			set Igb = Player(Jgb)
			call (Igb, Hgb)
			set Hgb = Hgb + 1
			if (Hgb >= Kgb) then
				set Hgb = 0
			endif
		endif
		set Jgb = Jgb + 1
		exitwhen Jgb == D
	endloop
endfunction

function Lgb takes nothing returns nothing
	call Ggb(D)
endfunction

function Mgb takes nothing returns nothing
	call Ggb(D)
endfunction

function Ngb takes nothing returns nothing
	call (2)
	call (2)
	call Ggb(2)
endfunction

function Ogb takes nothing returns nothing
	local gametype Pgb = GetGameTypeSelected()
	if (Pgb == ) then
		call Lgb()
	elseif (Pgb == ) then
		call Mgb()
	elseif (Pgb == ) then
	elseif (Pgb == ) then
		call Ngb()
	elseif (Pgb == ) then
		call Ggb(2)
	elseif (Pgb == ) then
		call Ggb(3)
	elseif (Pgb == ) then
		call Ggb(4)
	else
	endif
endfunction

function Qgb takes nothing returns nothing
	if rg then
		call (pg)
	endif
endfunction

function Rgb takes nothing returns nothing
	if rg then
		call (qg)
	endif
endfunction

function Sgb takes nothing returns nothing
	local real Tgb = em()
	if (Tgb >= L and Tgb < M) and not sg then
		set sg = true
		call (mg, false, true)
		call (lg)
	endif
endfunction

function Ugb takes nothing returns nothing
	local real Vgb = em()
	if (Vgb < L or Vgb >= M) and sg then
		set sg = false
		call (lg, false, true)
		call (mg)
	endif
endfunction

function Wgb takes nothing returns nothing
	set pg = CreateSoundFromLabel("RoosterSound", false, false, false, 10000, 10000)
	set qg = CreateSoundFromLabel("WolfSound", false, false, false, 10000, 10000)
	set ng = CreateTrigger()
	call (ng, , , L)
	call (ng, function )
	set og = CreateTrigger()
	call (og, , , M)
	call (og, function )
	set jg = CreateTrigger()
	call (jg, , , L)
	call (jg, , , M)
	call (jg, function )
	set kg = CreateTrigger()
	call (kg, , , L)
	call (kg, , , M)
	call (kg, function )
endfunction

function Xgb takes nothing returns nothing
	local integer ahb
	local integer Zgb
	local version Ygb
	set Wi = Filter(function )
	set Xi = Filter(function )
	set Yi = Filter(function )
	set Zi = Filter(function )
	set aj = Filter(function )
	set bj = Filter(function )
	set cj = Filter(function )
	set ahb = 0
	loop
		exitwhen ahb == G
		set Uf[ahb] = CreateForce()
		call (Uf[ahb], Player(ahb))
		set ahb = ahb + 1
	endloop
	set Tf = CreateForce()
	call (Tf, null)
	set ih = GetGameSpeed()
	set jh = IsFogEnabled()
	set kh = IsFogMaskEnabled()
	set ahb = 0
	loop
		exitwhen ahb >= Pb
		set xh[ahb] = null
		set yh[ahb] = false
		set ahb = ahb + 1
	endloop
	set ig = false
	set Zgb = 0
	set ahb = 0
	loop
		exitwhen ahb >= D
		if (GetPlayerController(Player(ahb)) ==  and GetPlayerSlotState(Player(ahb)) == ) then
			set Zgb = Zgb + 1
		endif
		set ahb = ahb + 1
	endloop
	set ig = (Zgb == 1)
	set tg = CreateSoundFromLabel("Rescue", false, false, false, 10000, 10000)
	set ug = CreateSoundFromLabel("QuestNew", false, false, false, 10000, 10000)
	set vg = CreateSoundFromLabel("QuestUpdate", false, false, false, 10000, 10000)
	set wg = CreateSoundFromLabel("QuestCompleted", false, false, false, 10000, 10000)
	set xg = CreateSoundFromLabel("QuestFailed", false, false, false, 10000, 10000)
	set yg = CreateSoundFromLabel("Hint", false, false, false, 10000, 10000)
	set zg = CreateSoundFromLabel("SecretFound", false, false, false, 10000, 10000)
	set Ag = CreateSoundFromLabel("ItemReward", false, false, false, 10000, 10000)
	set Bg = CreateSoundFromLabel("Warning", false, false, false, 10000, 10000)
	set Cg = CreateSoundFromLabel("QuestCompleted", false, false, false, 10000, 10000)
	set Dg = CreateSoundFromLabel("QuestFailed", false, false, false, 10000, 10000)
	call vB()
	set Ygb = VersionGet()
	if (Ygb == ) then
		set Vf = Z
	else
		set Vf = ab
	endif
endfunction

function bhb takes nothing returns nothing
	set Ah = CreateTrigger()
	call (Ah, zh)
	call (Ah, function )
endfunction

function chb takes nothing returns nothing
	set Wf = Rect(GetCameraBoundMinX() - GetCameraMargin(), GetCameraBoundMinY() - GetCameraMargin(), GetCameraBoundMaxX() + GetCameraMargin(), GetCameraBoundMaxY() + GetCameraMargin())
	set Xf = bo()
endfunction

function dhb takes nothing returns nothing
	local integer ehb
	set ehb = 0
	loop
		if (not GetPlayerTechResearched(Player(ehb), 'Rhrt', true)) then
			call (Player(ehb), 'hrtt', 0)
		endif
		if (not GetPlayerTechResearched(Player(ehb), 'Robk', true)) then
			call (Player(ehb), 'otbk', 0)
		endif
		call (Player(ehb), 'uske', H)
		set ehb = ehb + 1
		exitwhen ehb == D
	endloop
endfunction

function fhb takes item ihb returns nothing
	local itemtype hhb = GetItemType(ihb)
	local integer ghb = GetItemLevel(ihb)
	if (hhb == ) then
		set Gg[ghb] = true
	elseif (hhb == ) then
		set Hg[ghb] = true
	elseif (hhb == ) then
		set Ig[ghb] = true
	else
	endif
endfunction

function jhb takes nothing returns nothing
	local integer lhb = 0
	local integer khb
	loop
		set khb = ChooseRandomItemEx(Kg, Jg)
		exitwhen IsItemIdSellable(khb)
		set lhb = lhb + 1
		if (lhb > eb) then
			return
		endif
	endloop
	call (GetEnumUnit(), khb, 1, 1)
endfunction

function mhb takes itemtype phb, integer ohb returns nothing
	local group nhb
	set Kg = phb
	set Jg = ohb
	set nhb = CreateGroup()
	call (nhb, "marketplace", null)
	call (nhb, function )
	call (nhb)
endfunction

function qhb takes nothing returns nothing
	local integer vhb
	local itemtype uhb
	local integer thb = 0
	local integer shb = 0
	local integer rhb
	set rhb = 1
	loop
		if (Gg[rhb]) then
			set shb = shb + 1
			if (GetRandomInt(1, shb) == 1) then
				set uhb = 
				set thb = rhb
			endif
		endif
		if (Hg[rhb]) then
			set shb = shb + 1
			if (GetRandomInt(1, shb) == 1) then
				set uhb = 
				set thb = rhb
			endif
		endif
		if (Ig[rhb]) then
			set shb = shb + 1
			if (GetRandomInt(1, shb) == 1) then
				set uhb = 
				set thb = rhb
			endif
		endif
		set rhb = rhb + 1
		exitwhen rhb > K
	endloop
	if (shb == 0) then
		return
	endif
	call mhb(uhb, thb)
endfunction

function whb takes nothing returns nothing
	call qhb()
	call (Fg, db, true, function )
endfunction

function xhb takes nothing returns nothing
	call (GetSellingUnit(), GetItemTypeId(GetSoldItem()))
endfunction

function yhb takes nothing returns nothing
	local integer zhb
	set zhb = 0
	loop
		set Gg[zhb] = false
		set Hg[zhb] = false
		set Ig[zhb] = false
		set zhb = zhb + 1
		exitwhen zhb > K
	endloop
	call (I)
	call (J)
	set Fg = CreateTimer()
	call (Fg, cb, false, function )
	set Eg = CreateTrigger()
	call (Eg, Player(), , null)
	call (Eg, function )
endfunction

function Ahb takes nothing returns nothing
	set gg = true
	call (fg)
endfunction

function Bhb takes nothing returns nothing
	set fg = CreateTimer()
	call (fg, y, false, function )
endfunction

function Chb takes nothing returns nothing
	call fN()
	call Xgb()
	call bhb()
	call nY()
	call Wgb()
	call chb()
	call dhb()
	call yhb()
	call Bhb()
endfunction

function Dhb takes nothing returns nothing
	set qi = 0
endfunction

function Ehb takes integer Ghb, integer Fhb returns nothing
	set ri[qi] = Ghb
	set si[qi] = Fhb
	set qi = qi + 1
endfunction

function Hhb takes nothing returns integer
	local integer Mhb = 0
	local integer Lhb = 0
	local integer Khb
	local integer Jhb = -1
	local boolean Ihb
	if (qi == 0) then
		return -1
	endif
	set Khb = 0
	loop
		set Mhb = Mhb + si[Khb]
		set Khb = Khb + 1
		exitwhen Khb == qi
	endloop
	set Lhb = GetRandomInt(1, Mhb)
	set Khb = 0
	set Mhb = 0
	set Ihb = false
	loop
		set Mhb = Mhb + si[Khb]
		if (Lhb <= Mhb) then
			set Jhb = ri[Khb]
			set Ihb = true
		endif
		set Khb = Khb + 1
		if (Khb == qi) then
			set Ihb = true
		endif
		exitwhen Ihb == true
	endloop
	return Jhb
endfunction

function Nhb takes unit Vhb, integer Uhb returns item
	local real Thb
	local real Shb
	local real Rhb = 32
	local real Qhb
	local real Phb
	local item Ohb
	if (Uhb == -1) then
		return null
	endif
	set Qhb = GetUnitX(Vhb)
	set Phb = GetUnitY(Vhb)
	set Thb = GetRandomReal(Qhb - Rhb, Qhb + Rhb)
	set Shb = GetRandomReal(Phb - Rhb, Phb + Rhb)
	set Ohb = CreateItem(Uhb, Thb, Shb)
	call (Ohb, GetUnitTypeId(Vhb))
	call fhb(Ohb)
	return Ohb
endfunction

function Whb takes widget dib, integer cib returns item
	local real bib
	local real aib
	local real Zhb = 32
	local real Yhb
	local real Xhb
	if (cib == -1) then
		return null
	endif
	set Yhb = GetWidgetX(dib)
	set Xhb = GetWidgetY(dib)
	set bib = GetRandomReal(Yhb - Zhb, Yhb + Zhb)
	set aib = GetRandomReal(Xhb - Zhb, Xhb + Zhb)
	return CreateItem(cib, bib, aib)
endfunction